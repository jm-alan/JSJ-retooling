{"body":"I have a function `foo` which makes an asynchronous request. How can I return the response/result from `foo`? \r\n\r\nI tried returning the value from the callback, as well as assigning the result to a local variable inside the function and returning that one, but none of those ways actually return the response (they all return `undefined` or whatever the initial value of the variable `result` is).\r\n\r\n**Example using jQuery&#39;s `ajax` function:**\r\n\r\n    function foo() {\r\n        var result;\r\n\r\n        $.ajax({\r\n            url: &#39;...&#39;,\r\n            success: function(response) {\r\n                result = response;\r\n                // return response; // &lt;- I tried that one as well\r\n            }\r\n        });\r\n\r\n        return result; // It always returns `undefined`\r\n    }\r\n\r\n**Example using node.js:**\r\n\r\n    function foo() {\r\n        var result;\r\n\r\n        fs.readFile(&quot;path/to/file&quot;, function(err, data) {\r\n            result = data;\r\n            // return data; // &lt;- I tried that one as well\r\n        });\r\n\r\n        return result; // It always returns `undefined`\r\n    }\r\n\r\n**Example using the `then` block of a promise:**\r\n\r\n    function foo() {\r\n        var result;\r\n\r\n        fetch(url).then(function(response) {\r\n            result = response;\r\n            // return response; // &lt;- I tried that one as well\r\n        });\r\n\r\n        return result; // It always returns `undefined`\r\n    }","title":"How do I return the response from an asynchronous call?","answers":[{"score":5913,"body_markdown":"&gt; *&amp;rarr; For a more general explanation of async behaviour with different examples, please see* https://stackoverflow.com/q/23667086/218196  \r\n&gt; \r\n&gt; *&amp;rarr; If you already understand the problem, skip to the possible solutions below.*\r\n\r\n# The problem \r\n\r\nThe **A** in [Ajax][1] stands for [**asynchronous**][2] . That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, `$.ajax` returns immediately and the next statement, `return result;`, is executed before the function you passed as `success` callback was even called.\r\n\r\nHere is an analogy which hopefully makes the difference between synchronous and asynchronous flow clearer: \r\n\r\n## Synchronous\r\n\r\nImagine you make a phone call to a friend and ask him to look something up for you. Although it might take a while, you wait on the phone and stare into space, until your friend gives you the answer that you needed.\r\n\r\nThe same is happening when you make a function call containing &quot;normal&quot; code:\r\n\r\n    function findItem() {\r\n        var item;\r\n        while(item_not_found) {\r\n            // search\r\n        }\r\n        return item;\r\n    }\r\n\r\n    var item = findItem();\r\n\r\n    // Do something with item\r\n    doSomethingElse();\r\n\r\nEven though `findItem` might take a long time to execute, any code coming after `var item = findItem();` has to *wait* until the function returns the result.\r\n\r\n\r\n## Asynchronous\r\n\r\nYou call your friend again for the same reason. But this time you tell him that you are in a hurry and he should *call you back* on your mobile phone. You hang up, leave the house, and do whatever you planned to do. Once your friend calls you back, you are dealing with the information he gave to you.\r\n\r\nThat&#39;s exactly what&#39;s happening when you do an Ajax request. \r\n\r\n    findItem(function(item) {\r\n        // Do something with the item\r\n    });\r\n    doSomethingElse();\r\n\r\nInstead of waiting for the response, the execution continues immediately and the statement after the Ajax call is executed. To get the response eventually, you provide a function to be called once the response was received, a *callback* (notice something? *call back* ?). Any statement coming after that call is executed before the callback is called.\r\n\r\n---\r\n\r\n# Solution(s)\r\n\r\n**Embrace the asynchronous nature of JavaScript!** While certain asynchronous operations provide synchronous counterparts (so does &quot;Ajax&quot;), it&#39;s generally discouraged to use them, especially in a browser context.\r\n\r\nWhy is it bad do you ask?\r\n\r\nJavaScript runs in the UI thread of the browser and any long-running process will lock the UI, making it unresponsive. Additionally, there is an upper limit on the execution time for JavaScript and the browser will ask the user whether to continue the execution or not. \r\n\r\nAll of this is a really bad user experience. The user won&#39;t be able to tell whether everything is working fine or not. Furthermore, the effect will be worse for users with a slow connection.\r\n\r\nIn the following we will look at three different solutions that are all building on top of each other:\r\n\r\n - **Promises with `async/await`** (ES2017+, available in older browsers if you use a transpiler or regenerator)\r\n - **Callbacks** (popular in node)\r\n - **Promises with `then()`** (ES2015+, available in older browsers if you use one of the many promise libraries)\r\n\r\n**All three are available in current browsers, and node 7+.** \r\n\r\n---\r\n\r\n## ES2017+: Promises with [`async/await`][3]\r\n\r\nThe ECMAScript version released in 2017 introduced *syntax-level support* for asynchronous functions. With the help of `async` and `await`, you can write asynchronous in a &quot;synchronous style&quot;. The code is still asynchronous, but it&#39;s easier to read/understand.\r\n\r\n`async/await` builds on top of promises: an `async` function always returns a promise. `await` &quot;unwraps&quot; a promise and either result in the value the promise was resolved with or throws an error if the promise was rejected.\r\n\r\n**Important:** You can only use `await` inside an `async` function. Right now, top-level `await` isn&#39;t yet supported, so you might have to make an async IIFE ([Immediately Invoked Function Expression](https://en.wikipedia.org/wiki/Immediately_invoked_function_expression)) to start an `async` context.\r\n\r\nYou can read more about [`async`][3] and [`await`][4] on MDN.\r\n\r\nHere is an example that builds on top of delay above:\r\n\r\n    // Using &#39;superagent&#39; which will return a promise.\r\n    var superagent = require(&#39;superagent&#39;)\r\n\r\n    // This is isn&#39;t declared as `async` because it already returns a promise\r\n    function delay() {\r\n      // `delay` returns a promise\r\n      return new Promise(function(resolve, reject) {\r\n        // Only `delay` is able to resolve or reject the promise\r\n        setTimeout(function() {\r\n          resolve(42); // After 3 seconds, resolve the promise with value 42\r\n        }, 3000);\r\n      });\r\n    }\r\n\r\n    \r\n    async function getAllBooks() {\r\n      try {\r\n        // GET a list of book IDs of the current user\r\n        var bookIDs = await superagent.get(&#39;/user/books&#39;);\r\n        // wait for 3 seconds (just for the sake of this example)\r\n        await delay();\r\n        // GET information about each book\r\n        return await superagent.get(&#39;/books/ids=&#39;+JSON.stringify(bookIDs));\r\n      } catch(error) {\r\n        // If any of the awaited promises was rejected, this catch block\r\n        // would catch the rejection reason\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // Start an IIFE to use `await` at the top level\r\n    (async function(){\r\n      let books = await getAllBooks();\r\n      console.log(books);\r\n    })();\r\n    \r\nCurrent [browser][5] and [node][6] versions support `async/await`. You can also support older environments by transforming your code to ES5 with the help of [regenerator][7] (or tools that use regenerator, such as [Babel][8]).\r\n\r\n---\r\n\r\n## Let functions accept *callbacks*\r\n\r\nA callback is when function 1 is passed to function 2. Function 2 can call function 1 whenever it is ready. In the context of an asynchronous process, the callback will be called whenever the asynchronous process is done. Usually, the result is passed to the callback.\r\n\r\nIn the example of the question, you can make `foo` accept a callback and use it as `success` callback. So this\r\n\r\n    var result = foo();\r\n    // Code that depends on &#39;result&#39;\r\n\r\nbecomes\r\n\r\n    foo(function(result) {\r\n        // Code that depends on &#39;result&#39;\r\n    });\r\n\r\nHere we defined the function &quot;inline&quot; but you can pass any function reference:\r\n\r\n    function myCallback(result) {\r\n        // Code that depends on &#39;result&#39;\r\n    }\r\n    \r\n    foo(myCallback);\r\n\r\n`foo` itself is defined as follows:\r\n\r\n    function foo(callback) {\r\n        $.ajax({\r\n            // ...\r\n            success: callback\r\n        });\r\n    }\r\n\r\n`callback` will refer to the function we pass to `foo` when we call it and we pass it on to `success`. I.e. once the Ajax request is successful, `$.ajax` will call `callback` and pass the response to the callback (which can be referred to with `result`, since this is how we defined the callback).\r\n    \r\n\r\nYou can also process the response before passing it to the callback:\r\n\r\n    function foo(callback) {\r\n        $.ajax({\r\n            // ...\r\n            success: function(response) {\r\n                // For example, filter the response\r\n                callback(filtered_response);\r\n            }\r\n        });\r\n    }\r\n\r\nIt&#39;s easier to write code using callbacks than it may seem. After all, JavaScript in the browser is heavily event-driven (DOM events). Receiving the Ajax response is nothing else but an event.  \r\nDifficulties could arise when you have to work with third-party code, but most problems can be solved by just thinking through the application flow.\r\n\r\n---\r\n\r\n## ES2015+: Promises with [then()][9]\r\n\r\nThe [Promise API][9] is a new feature of ECMAScript 6 (ES2015), but it has good [browser support][10] already. There are also many libraries which implement the standard Promises API and provide additional methods to ease the use and composition of asynchronous functions (e.g. [bluebird][11]).\r\n\r\nPromises are containers for *future* values. When the promise receives the value (it is *resolved*) or when it is canceled (*rejected*), it notifies all of its &quot;listeners&quot; who want to access this value.\r\n\r\nThe advantage over plain callbacks is that they allow you to decouple your code and they are easier to compose.\r\n\r\nHere is an example of using a promise:\r\n\r\n    function delay() {\r\n      // `delay` returns a promise\r\n      return new Promise(function(resolve, reject) {\r\n        // Only `delay` is able to resolve or reject the promise\r\n        setTimeout(function() {\r\n          resolve(42); // After 3 seconds, resolve the promise with value 42\r\n        }, 3000);\r\n      });\r\n    }\r\n    \r\n    delay()\r\n      .then(function(v) { // `delay` returns a promise\r\n        console.log(v); // Log the value once it is resolved\r\n      })\r\n      .catch(function(v) {\r\n        // Or do something else if it is rejected \r\n        // (it would not happen in this example, since `reject` is not called).\r\n      });\r\n\r\nApplied to our Ajax call we could use promises like this:\r\n\r\n    function ajax(url) {\r\n      return new Promise(function(resolve, reject) {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.onload = function() {\r\n          resolve(this.responseText);\r\n        };\r\n        xhr.onerror = reject;\r\n        xhr.open(&#39;GET&#39;, url);\r\n        xhr.send();\r\n      });\r\n    }\r\n    \r\n    ajax(&quot;/echo/json&quot;)\r\n      .then(function(result) {\r\n        // Code depending on result\r\n      })\r\n      .catch(function() {\r\n        // An error occurred\r\n      });\r\n\r\nDescribing all the advantages that promise offer is beyond the scope of this answer, but if you write new code, you should seriously consider them. They provide a great abstraction and separation of your code.\r\n\r\nMore information about promises: [HTML5 rocks - JavaScript Promises][12]\r\n\r\n### Side note: jQuery&#39;s deferred objects\r\n\r\n[Deferred objects][13] are jQuery&#39;s custom implementation of promises (before the Promise API was standardized). They behave almost like promises but expose a slightly different API.\r\n\r\nEvery Ajax method of jQuery already returns a &quot;deferred object&quot; (actually a promise of a deferred object) which you can just return from your function:\r\n\r\n    function ajax() {\r\n        return $.ajax(...);\r\n    }\r\n\r\n    ajax().done(function(result) {\r\n        // Code depending on result\r\n    }).fail(function() {\r\n        // An error occurred\r\n    });\r\n\r\n\r\n### Side note: Promise gotchas\r\n\r\nKeep in mind that promises and deferred objects are just *containers* for a future value, they are not the value itself. For example, suppose you had the following:\r\n\r\n    function checkPassword() {\r\n        return $.ajax({\r\n            url: &#39;/password&#39;,\r\n            data: {\r\n                username: $(&#39;#username&#39;).val(),\r\n                password: $(&#39;#password&#39;).val()\r\n            },\r\n            type: &#39;POST&#39;,\r\n            dataType: &#39;json&#39;\r\n        });\r\n    }\r\n    \r\n    if (checkPassword()) {\r\n        // Tell the user they&#39;re logged in\r\n    }\r\n\r\nThis code misunderstands the above asynchrony issues. Specifically, `$.ajax()` doesn&#39;t freeze the code while it checks the &#39;/password&#39; page on your server - it sends a request to the server and while it waits, it immediately returns a jQuery Ajax Deferred object, not the response from the server. That means the `if` statement is going to always get this Deferred object, treat it as `true`, and proceed as though the user is logged in. Not good.\r\n\r\nBut the fix is easy:\r\n\r\n    checkPassword()\r\n    .done(function(r) {\r\n        if (r) {\r\n            // Tell the user they&#39;re logged in\r\n        } else {\r\n            // Tell the user their password was bad\r\n        }\r\n    })\r\n    .fail(function(x) {\r\n        // Tell the user something bad happened\r\n    });\r\n\r\n---\r\n\r\n## Not recommended: Synchronous &quot;Ajax&quot; calls\r\n\r\nAs I mentioned, some(!) asynchronous operations have synchronous counterparts. I don&#39;t advocate their use, but for completeness&#39; sake, here is how you would perform a synchronous call:\r\n\r\n### Without jQuery\r\n\r\nIf you directly use a [`XMLHttpRequest`][14] object, pass `false` as third argument to [`.open`][15].\r\n\r\n### jQuery\r\n\r\nIf you use [jQuery][16], you can set the `async` option to `false`. Note that this option is *deprecated* since jQuery 1.8.\r\nYou can then either still use a `success` callback or access the `responseText` property of the [jqXHR object][17]:\r\n\r\n\r\n    function foo() {\r\n        var jqXHR = $.ajax({\r\n            //...\r\n            async: false\r\n        });\r\n        return jqXHR.responseText;\r\n    }\r\n\r\nIf you use any other jQuery Ajax method, such as `$.get`, `$.getJSON`, etc., you have to change it to `$.ajax` (since you can only pass configuration parameters to `$.ajax`).\r\n\r\n**Heads up!** It is not possible to make a synchronous [JSONP][18] request. JSONP by its very nature is always asynchronous (one more reason to not even consider this option).\r\n\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Ajax_(programming)\r\n  [2]: https://www.merriam-webster.com/dictionary/asynchronous\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await\r\n  [5]: https://kangax.github.io/compat-table/es2016plus/#test-async_functions\r\n  [6]: http://node.green/#ES2017-features-async-functions\r\n  [7]: https://github.com/facebook/regenerator\r\n  [8]: https://babeljs.io/\r\n  [9]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n  [10]: http://caniuse.com/#feat=promises &quot;caniuse&quot;\r\n  [11]: https://github.com/petkaantonov/bluebird\r\n  [12]: http://www.html5rocks.com/en/tutorials/es6/promises/\r\n  [13]: https://stackoverflow.com/questions/4866721/what-are-deferred-objects\r\n  [14]: https://xhr.spec.whatwg.org/\r\n  [15]: https://xhr.spec.whatwg.org/#the-open()-method\r\n  [16]: http://api.jquery.com/jQuery.ajax/\r\n  [17]: http://api.jquery.com/jQuery.ajax/#jqXHR\r\n  [18]: https://stackoverflow.com/questions/2067472/please-explain-jsonp"},{"score":1096,"body_markdown":"# If you&#39;re _not_ using jQuery in your code, this answer is for you\n \nYour code should be something along the lines of this:\n\n    function foo() {\n        var httpRequest = new XMLHttpRequest();\n        httpRequest.open(&#39;GET&#39;, &quot;/echo/json&quot;);\n        httpRequest.send();\n        return httpRequest.responseText;\n    }\n    \n    var result = foo(); // always ends up being &#39;undefined&#39;\n\nFelix Kling did a fine job writing an answer for people using jQuery for AJAX, I&#39;ve decided to provide an alternative for people who aren&#39;t.\n\n([Note, for those using the new `fetch` API, Angular or promises I&#39;ve added another answer below](https://stackoverflow.com/a/30180679/1348195))\n\n---------------\n# What you&#39;re facing\n\nThis is a short summary of &quot;Explanation of the problem&quot; from the other answer, if you&#39;re not sure after reading this, read that.\n\nThe **A** in AJAX stands for **asynchronous**. That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, [`.send`][1] returns immediately and the next statement, `return result;`, is executed before the function you passed as `success` callback was even called.\n\nThis means when you&#39;re returning, the listener you&#39;ve defined did not execute yet, which means the value you&#39;re returning has not been defined. \n\nHere is a simple analogy\n\n    function getFive(){ \n        var a;\n        setTimeout(function(){\n             a=5;\n        },10);\n        return a;\n    }\n[(Fiddle)][2]\n\nThe value of `a` returned is `undefined` since the `a=5` part has not executed yet. AJAX acts like this, you&#39;re returning the value before the server got the chance to tell your browser what that value is.\n\nOne possible solution to this problem is to code _re-actively_ , telling your program what to do when the calculation completed.\n\n    function onComplete(a){ // When the code completes, do this\n        alert(a);\n    }\n\n    function getFive(whenDone){ \n        var a;\n        setTimeout(function(){\n             a=5;\n             whenDone(a);\n        },10);\n    }\n\nThis is called [CPS][3]. Basically, we&#39;re passing `getFive` an action to perform when it completes, we&#39;re telling our code how to react when an event completes (like our AJAX call, or in this case the timeout).\n\nUsage would be:\n\n    getFive(onComplete);\n\nWhich should alert &quot;5&quot; to the screen. [(Fiddle)][4].\n\n# Possible solutions\n\nThere are basically two ways how to solve this:\n\n1. Make the AJAX call synchronous (lets call it SJAX).\n2. Restructure your code to work properly with callbacks.\n\n## 1. Synchronous AJAX - Don&#39;t do it!!\n\nAs for synchronous AJAX, **don&#39;t do it!** Felix&#39;s answer raises some compelling arguments about why it&#39;s a bad idea. To sum it up, it&#39;ll freeze the user&#39;s browser until the server returns the response and create a very bad user experience. Here is another short summary taken from MDN on why:\n\n&gt; XMLHttpRequest supports both synchronous and asynchronous communications. In general, however, asynchronous requests should be preferred to synchronous requests for performance reasons.\n&gt;\n&gt; In short, synchronous requests block the execution of code... ...this can cause serious issues...\n\n\n If you _have_ to do it, you can pass a flag: [Here is how:][5]\n\n\n    var request = new XMLHttpRequest();\n    request.open(&#39;GET&#39;, &#39;yourURL&#39;, false);  // `false` makes the request synchronous\n    request.send(null);\n     \n    if (request.status === 200) {// That&#39;s HTTP for &#39;ok&#39;\n      console.log(request.responseText);\n    }\n\n## 2. Restructure code\n\nLet your function accept a callback. In the example code `foo` can be made to accept a callback. We&#39;ll be telling our code how to _react_ when `foo` completes. \n\nSo:\n\n    var result = foo();\n    // code that depends on `result` goes here\n\nBecomes:\n\n    foo(function(result) {\n        // code that depends on `result`\n    });\n\nHere we passed an anonymous function, but we could just as easily pass a reference to an existing function, making it look like:\n\n    function myHandler(result) {\n        // code that depends on `result`\n    }\n    foo(myHandler);\n\nFor more details on how this sort of callback design is done, check Felix&#39;s answer. \n\nNow, let&#39;s define foo itself to act accordingly\n\n    function foo(callback) {\n        var httpRequest = new XMLHttpRequest();\n        httpRequest.onload = function(){ // when the request is loaded\n           callback(httpRequest.responseText);// we&#39;re calling our method\n        };\n        httpRequest.open(&#39;GET&#39;, &quot;/echo/json&quot;);\n        httpRequest.send();\n    }\n[(fiddle)][6]\n\nWe have now made our foo function accept an action to run when the AJAX completes successfully, we can extend this further by checking if the response status is not 200 and acting accordingly (create a fail handler and such). Effectively solving our issue.\n\nIf you&#39;re still having a hard time understanding this [read the AJAX getting started guide][7] at MDN.\n\n\n  [1]: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#send%28%29\n  [2]: http://jsfiddle.net/7RK3k/\n  [3]: http://en.wikipedia.org/wiki/Continuation-passing_style\n  [4]: http://jsfiddle.net/PAjZR/\n  [5]: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request\n  [6]: http://jsfiddle.net/DAcWT/\n  [7]: https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started"},{"score":410,"body_markdown":"**[XMLHttpRequest][1] 2** (first of all read the answers from [Benjamin Gruenbaum][2] &amp; [Felix Kling][3])\r\n\r\nIf you don&#39;t use jQuery and want a nice short XMLHttpRequest 2 which works on the modern browsers and also on the mobile browsers I suggest to use it this way:\r\n\r\n    function ajax(a, b, c){ // URL, callback, just a placeholder\r\n      c = new XMLHttpRequest;\r\n      c.open(&#39;GET&#39;, a);\r\n      c.onload = b;\r\n      c.send()\r\n    }\r\n\r\nAs you can see:\r\n\r\n1. It&#39;s shorter than all other functions Listed.\r\n2. The callback is set directly (so no extra unnecessary closures).\r\n3. It uses the new onload (so you don&#39;t have to check for readystate &amp;&amp; status)\r\n4. There are some other situations which I don&#39;t remember that make the XMLHttpRequest 1 annoying.\r\n\r\nThere are two ways to get the response of this Ajax call (three using the XMLHttpRequest var name):\r\n\r\nThe simplest:\r\n\r\n    this.response\r\n\r\nOr if for some reason you `bind()` the callback to a class:\r\n\r\n    e.target.response\r\n\r\nExample:\r\n\r\n    function callback(e){\r\n      console.log(this.response);\r\n    }\r\n    ajax(&#39;URL&#39;, callback);\r\n\r\nOr (the above one is better anonymous functions are always a problem):\r\n\r\n    ajax(&#39;URL&#39;, function(e){console.log(this.response)});\r\n\r\nNothing easier.\r\n\r\nNow some people will probably say that it&#39;s better to use onreadystatechange or the even the XMLHttpRequest variable name. That&#39;s wrong.\r\n\r\nCheck out [XMLHttpRequest advanced features][4]\r\n\r\nIt supported all *modern browsers. And I can confirm as I&#39;m using this approach since XMLHttpRequest 2 exists. I never had any type of problem on all browsers I use.\r\n\r\nonreadystatechange is only useful if you want to get the headers on state 2.\r\n\r\nUsing the `XMLHttpRequest` variable name is another big error as you need to execute the callback inside the onload/oreadystatechange closures else you lost it.\r\n\r\n----------\r\n\r\nNow if you want something more complex using post and FormData you can easily extend this function:\r\n\r\n    function x(a, b, e, d, c){ // URL, callback, method, formdata or {key:val},placeholder\r\n      c = new XMLHttpRequest;\r\n      c.open(e||&#39;get&#39;, a);\r\n      c.onload = b;\r\n      c.send(d||null)\r\n    }\r\n\r\nAgain ... it&#39;s a very short function, but it does get &amp; post.\r\n\r\nExamples of usage:\r\n\r\n    x(url, callback); // By default it&#39;s get so no need to set\r\n    x(url, callback, &#39;post&#39;, {&#39;key&#39;: &#39;val&#39;}); // No need to set post data\r\n\r\nOr pass a full form element (`document.getElementsByTagName(&#39;form&#39;)[0]`):\r\n\r\n    var fd = new FormData(form);\r\n    x(url, callback, &#39;post&#39;, fd);\r\n\r\nOr set some custom values:\r\n\r\n    var fd = new FormData();\r\n    fd.append(&#39;key&#39;, &#39;val&#39;)\r\n    x(url, callback, &#39;post&#39;, fd);\r\n\r\nAs you can see I didn&#39;t implement sync... it&#39;s a bad thing.\r\n\r\nHaving said that ... why don&#39;t do it the easy way?\r\n\r\n----------\r\n\r\nAs mentioned in the comment the use of error &amp;&amp; synchronous does completely break the point of the answer. Which is a nice short way to use Ajax in the proper way?\r\n\r\n*Error handler*\r\n\r\n    function x(a, b, e, d, c){ // URL, callback, method, formdata or {key:val}, placeholder\r\n      c = new XMLHttpRequest;\r\n      c.open(e||&#39;get&#39;, a);\r\n      c.onload = b;\r\n      c.onerror = error;\r\n      c.send(d||null)\r\n    }\r\n\r\n    function error(e){\r\n      console.log(&#39;--Error--&#39;, this.type);\r\n      console.log(&#39;this: &#39;, this);\r\n      console.log(&#39;Event: &#39;, e)\r\n    }\r\n    function displayAjax(e){\r\n      console.log(e, this);\r\n    }\r\n    x(&#39;WRONGURL&#39;, displayAjax);\r\n\r\nIn the above script, you have an error handler which is statically defined so it does not compromise the function. The error handler can be used for other functions too.\r\n\r\nBut to really get out an error the **only** way is to write a wrong URL in which case every browser throws an error.\r\n\r\nError handlers are maybe useful if you set custom headers, set the responseType to blob array buffer or whatever...\r\n\r\nEven if you pass &#39;POSTAPAPAP&#39; as the method it won&#39;t throw an error.\r\n\r\nEven if you pass &#39;fdggdgilfdghfldj&#39; as formdata it won&#39;t throw an error.\r\n\r\nIn the first case the error is inside the `displayAjax()` under `this.statusText` as `Method not Allowed`.\r\n\r\nIn the second case, it simply works. You have to check at the server side if you passed the right post data.\r\n\r\ncross-domain not allowed throws error automatically.\r\n\r\nIn the error response, there are no error codes.\r\n\r\nThere is only the `this.type` which is set to error.\r\n\r\nWhy add an error handler if you totally have no control over errors?\r\nMost of the errors are returned inside this in the callback function `displayAjax()`.\r\n\r\nSo: No need for error checks if you&#39;re able to copy and paste the URL properly. ;)\r\n\r\n*PS: As the first test I wrote x(&#39;x&#39;, displayAjax)..., and it totally got a response...??? So I checked the folder where the HTML is located, and there was a file called &#39;x.xml&#39;. So even if you forget the extension of your file XMLHttpRequest 2 WILL FIND IT*. I LOL&#39;d\r\n\r\n----------\r\n\r\n*Read a file synchronous*\r\n\r\n**Don&#39;t do that.**\r\n\r\nIf you want to block the browser for a while load a nice big `.txt` file synchronous.\r\n\r\n    function omg(a, c){ // URL\r\n      c = new XMLHttpRequest;\r\n      c.open(&#39;GET&#39;, a, true);\r\n      c.send();\r\n      return c; // Or c.response\r\n    }\r\n\r\nNow you can do\r\n\r\n     var res = omg(&#39;thisIsGonnaBlockThePage.txt&#39;);\r\n\r\nThere is no other way to do this in a non-asynchronous way. (Yeah, with setTimeout loop... but seriously?)\r\n\r\nAnother point is... if you work with APIs or just your own list&#39;s files or whatever you always use different functions for each request...\r\n\r\nOnly if you have a page where you load always the same XML/JSON or whatever you need only one function. In that case, modify a little the Ajax function and replace b with your special function.\r\n\r\n----------\r\n\r\nThe functions above are for basic use.\r\n\r\nIf you want to EXTEND the function...\r\n\r\nYes, you can.\r\n\r\nI&#39;m using a lot of APIs and one of the first functions I integrate into every HTML page is the first Ajax function in this answer, with GET only...\r\n\r\nBut you can do a lot of stuff with XMLHttpRequest 2:\r\n\r\nI made a download manager (using ranges on both sides with resume, filereader, filesystem), various image resizers converters using canvas, populate web SQL databases with base64images and much more... But in these cases you should create a function only for that purpose... sometimes you need a blob, array buffers, you can set headers, override mimetype and there is a lot more...\r\n\r\nBut the question here is how to return an Ajax response... (I added an easy way.)\r\n\r\n\r\n  [1]: http://en.wikipedia.org/wiki/XMLHttpRequest\r\n  [2]: https://stackoverflow.com/a/16825593/19068\r\n  [3]: https://stackoverflow.com/a/14220323/19068\r\n  [4]: http://caniuse.com/xhr2"},{"score":242,"body_markdown":"The simplest solution is create a JavaScript function and call it for the Ajax `success` callback.\r\n\r\n    function callServerAsync(){\r\n        $.ajax({\r\n            url: &#39;...&#39;,\r\n            success: function(response) {\r\n\r\n                successCallback(response);\r\n            }\r\n        });\r\n    }\r\n\r\n    function successCallback(responseObj){\r\n        // Do something like read the response and show data\r\n        alert(JSON.stringify(responseObj)); // Only applicable to JSON response\r\n    }\r\n\r\n    function foo(callback) {\r\n     \r\n        $.ajax({\r\n            url: &#39;...&#39;,\r\n            success: function(response) {\r\n               return callback(null, response);\r\n            }\r\n        });\r\n    }\r\n\r\n    var result = foo(function(err, result){\r\n              if (!err)\r\n               console.log(result);    \r\n    }); \r\n\r\n"},{"score":256,"body_markdown":"You are using Ajax incorrectly. The idea is not to have it return anything, but instead hand off the data to something called a callback function, which handles the data.\r\n\r\nThat is:\r\n\r\n    function handleData( responseData ) {\r\n\r\n        // Do what you want with the data\r\n        console.log(responseData);\r\n    }\r\n\r\n    $.ajax({\r\n        url: &quot;hi.php&quot;,\r\n        ...\r\n        success: function ( data, status, XHR ) {\r\n            handleData(data);\r\n        }\r\n    });\r\n\r\nReturning anything in the submit handler will not do anything. You must instead either hand off the data, or do what you want with it directly inside the success function.\r\n"},{"score":165,"body_markdown":"Angular1\r\n--------\r\n\r\nFor people who are using [AngularJS][1], can handle this situation using `Promises`.\r\n\r\n[Here][2] it says,\r\n\r\n&gt; Promises can be used to unnest asynchronous functions and allows one to chain multiple functions together.\r\n\r\nYou can find a nice explanation [here][3] also.\r\n\r\nExample found in [docs][4] mentioned below.\r\n\r\n      promiseB = promiseA.then(\r\n        function onSuccess(result) {\r\n          return result + 1;\r\n        }\r\n        ,function onError(err) {\r\n          //Handle error\r\n        }\r\n      );\r\n\r\n     // promiseB will be resolved immediately after promiseA is resolved \r\n     // and its value will be the result of promiseA incremented by 1.\r\n\r\nAngular2 and Later\r\n------------------\r\n\r\nIn `Angular2` with look at the following example, but its [recommended][5] to use `Observables` with `Angular2`.\r\n\r\n     search(term: string) {\r\n         return this.http\r\n      .get(`https://api.spotify.com/v1/search?q=${term}&amp;type=artist`)\r\n      .map((response) =&gt; response.json())\r\n      .toPromise();\r\n  }\r\n\r\nYou can consume that in this way,\r\n\r\n    search() {\r\n        this.searchService.search(this.searchField.value)\r\n          .then((result) =&gt; {\r\n        this.result = result.artists.items;\r\n      })\r\n      .catch((error) =&gt; console.error(error));\r\n    }\r\n\r\nSee the [original][6] post here. But Typescript does not support [native es6 Promises][7], if you want to use it, you might need plugin for that.\r\n\r\nAdditionally here is the promises [spec][8] define here.\r\n\r\n\r\n  [1]: http://en.wikipedia.org/wiki/AngularJS\r\n  [2]: http://liamkaufman.com/blog/2013/09/09/using-angularjs-promises/\r\n  [3]: http://andyshora.com/promises-angularjs-explained-as-cartoon.html\r\n  [4]: https://docs.angularjs.org/api/ng/service/$q\r\n  [5]: https://angular-2-training-book.rangle.io/handout/observables/observables_vs_promises.html\r\n  [6]: https://angular-2-training-book.rangle.io/handout/http/requests_as_promises.html\r\n  [7]: http://www.datchley.name/es6-promises/\r\n  [8]: https://github.com/promises-aplus/promises-spec"},{"score":328,"body_markdown":"#If you&#39;re using promises, this answer is for you.\r\n\r\nThis means AngularJS, jQuery (with deferred), native XHR&#39;s replacement (fetch), EmberJS, BackboneJS&#39;s save or any node library that returns promises.\r\n\r\nYour code should be something along the lines of this:\r\n\r\n    function foo() {\r\n        var data;\r\n        // or $.get(...).then, or request(...).then, or query(...).then\r\n        fetch(&quot;/echo/json&quot;).then(function(response){\r\n            data = response.json();\r\n        });\r\n        return data;\r\n    }\r\n\r\n    var result = foo(); // result is always undefined no matter what.\r\n\r\nFelix Kling did a fine job writing an answer for people using jQuery with callbacks for AJAX. I have an answer for native XHR. This answer is for generic usage of promises either on the frontend or backend. \r\n\r\n\r\n---------------\r\n#The core issue\r\n\r\nThe JavaScript concurrency model in the browser and on the server with NodeJS/io.js is _asynchronous_ and _reactive_.\r\n\r\nWhenever you call a method that returns a promise, the `then` handlers are _always_ executed asynchronously - that is, __after__ the code below them that is not in a `.then` handler.\r\n\r\nThis means when you&#39;re returning `data` the `then` handler you&#39;ve defined did not execute yet. This in turn means that the value you&#39;re returning has not been set to the correct value in time. \r\n\r\nHere is a simple analogy for the issue:\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n        function getFive(){\r\n            var data;\r\n            setTimeout(function(){ // set a timer for one second in the future\r\n               data = 5; // after a second, do this\r\n            }, 1000);\r\n            return data;\r\n        }\r\n        document.body.innerHTML = getFive(); // `undefined` here and not 5\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe value of `data` is `undefined` since the `data = 5` part has not executed yet. It will likely execute in a second but by that time it is irrelevant to the returned value.\r\n\r\nSince the operation did not happen yet (AJAX, server call, IO, timer) you&#39;re returning the value before the request got the chance to tell your code what that value is.\r\n\r\nOne possible solution to this problem is to code _re-actively_ , telling your program what to do when the calculation completed. Promises actively enable this by being temporal (time-sensitive) in nature.\r\n\r\n#Quick recap on promises\r\n\r\nA Promise is a _value over time_. Promises have state, they start as pending with no value and can settle to:\r\n\r\n - __fulfilled__ meaning that the computation completed successfully.\r\n - __rejected__ meaning that the computation failed.\r\n\r\nA promise can only change states _once_ after which it will always stay at the same state forever. You can attach `then` handlers to promises to extract their value and handle errors. `then` handlers allow [chaining](https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks) of calls. Promises are created by [using APIs that return them](https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises). For example, the more modern AJAX replacement `fetch` or jQuery&#39;s `$.get` return promises.\r\n\r\nWhen we call `.then` on a promise and _return_ something from it - we get a promise for _the processed value_. If we return another promise we&#39;ll get amazing things, but let&#39;s hold our horses.\r\n\r\n# With promises\r\n\r\nLet&#39;s see how we can solve the above issue with promises. First, let&#39;s demonstrate our understanding of promise states from above by using the [Promise constructor](https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise) for creating a delay function:\r\n\r\n    function delay(ms){ // takes amount of milliseconds\r\n        // returns a new promise\r\n        return new Promise(function(resolve, reject){\r\n            setTimeout(function(){ // when the time is up\r\n                resolve(); // change the promise to the fulfilled state\r\n            }, ms);\r\n        });\r\n    }\r\n\r\nNow, after we [converted setTimeout](stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises) to use promises, we can use `then` to make it count:\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function delay(ms){ // takes amount of milliseconds\r\n      // returns a new promise\r\n      return new Promise(function(resolve, reject){\r\n        setTimeout(function(){ // when the time is up\r\n          resolve(); // change the promise to the fulfilled state\r\n        }, ms);\r\n      });\r\n    }\r\n\r\n    function getFive(){\r\n      // we&#39;re RETURNING the promise, remember, a promise is a wrapper over our value\r\n      return delay(100).then(function(){ // when the promise is ready\r\n          return 5; // return the value 5, promises are all about return values\r\n      })\r\n    }\r\n    // we _have_ to wrap it like this in the call site, we can&#39;t access the plain value\r\n    getFive().then(function(five){ \r\n       document.body.innerHTML = five;\r\n    });\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nBasically, instead of returning a _value_ which we can&#39;t do because of the concurrency model - we&#39;re returning a _wrapper_ for a value that we can _unwrap_ with `then`. It&#39;s like a box you can open with `then`.\r\n\r\n###Applying this\r\n\r\nThis stands the same for your original API call, you can:\r\n\r\n\r\n    function foo() {\r\n        // RETURN the promise\r\n        return fetch(&quot;/echo/json&quot;).then(function(response){\r\n            return response.json(); // process it inside the `then`\r\n        });\r\n    }\r\n\r\n    foo().then(function(response){\r\n        // access the value inside the `then`\r\n    })\r\n\r\nSo this works just as well. We&#39;ve learned we can&#39;t return values from already asynchronous calls but we can use promises and chain them to perform processing. We now know how to return the response from an asynchronous call.\r\n\r\n#ES2015 (ES6)\r\n\r\nES6 introduces [generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) which are functions that can return in the middle and then resume the point they were at. This is typically useful for sequences, for example:\r\n\r\n    function* foo(){ // notice the star, this is ES6 so new browsers/node/io only\r\n        yield 1;\r\n        yield 2;\r\n        while(true) yield 3;\r\n    }\r\n\r\nIs a function that returns an _iterator_ over the sequence `1,2,3,3,3,3,....` which can be iterated. While this is interesting on its own and opens room for a lot of possibility there is one particular interesting case.\r\n\r\nIf the sequence we&#39;re producing is a sequence of actions rather than numbers - we can pause the function whenever an action is yielded and wait for it before we resume the function. So instead of a sequence of numbers, we need a sequence of _future_ values - that is: promises.\r\n\r\nThis somewhat tricky but very powerful trick lets us write asynchronous code in a synchronous manner. There are several &quot;runners&quot; that do this for you, writing one is a short few lines of code but is beyond the scope of this answer. I&#39;ll be using Bluebird&#39;s `Promise.coroutine` here, but there are other wrappers like `co` or `Q.async`. \r\n\r\n    var foo = coroutine(function*(){\r\n        var data = yield fetch(&quot;/echo/json&quot;); // notice the yield\r\n        // code here only executes _after_ the request is done\r\n        return data.json(); // data is defined\r\n    });\r\n\r\nThis method returns a promise itself, which we can consume from other coroutines. For example:\r\n\r\n    var main = coroutine(function*(){\r\n       var bar = yield foo(); // wait our earlier coroutine, it returns a promise\r\n       // server call done here, code below executes when done\r\n       var baz = yield fetch(&quot;/api/users/&quot;+bar.userid); // depends on foo&#39;s result\r\n       console.log(baz); // runs after both requests done\r\n    });\r\n    main();\r\n\r\n#ES2016 (ES7)\r\n \r\nIn ES7, this is further standardized, there are several proposals right now but in all of them you can `await` promise. This is just &quot;sugar&quot; (nicer syntax) for the ES6 proposal above by adding the `async` and `await` keywords. Making the above example:\r\n\r\n    async function foo(){\r\n        var data = await fetch(&quot;/echo/json&quot;); // notice the await\r\n        // code here only executes _after_ the request is done\r\n        return data.json(); // data is defined\r\n    }\r\n\r\nIt still returns a promise just the same :)"},{"score":101,"body_markdown":"Another approach to return a value from an asynchronous function, is to pass in an object that will store the result from the asynchronous function.\r\n\r\nHere is an example of the same:\r\n\r\n    var async = require(&quot;async&quot;);\r\n\r\n    // This wires up result back to the caller\r\n    var result = {};\r\n    var asyncTasks = [];\r\n    asyncTasks.push(function(_callback){\r\n        // some asynchronous operation\r\n        $.ajax({\r\n            url: &#39;...&#39;,\r\n            success: function(response) {\r\n                result.response = response;\r\n                _callback();\r\n            }\r\n        });\r\n    });\r\n\r\n    async.parallel(asyncTasks, function(){\r\n        // result is available after performing asynchronous operation\r\n        console.log(result)\r\n        console.log(&#39;Done&#39;);\r\n    });\r\n\r\nI am using the `result` object to store the value during the asynchronous operation. This allows the result be available even after the asynchronous job.\r\n\r\nI use this approach a lot. I would be interested to know how well this approach works where wiring the result back through consecutive modules is involved.\r\n"},{"score":38,"body_markdown":"**Short answer**: Your `foo()` method returns immediately, while the `$ajax()` call executes asynchronously *after the function returns*. The problem is then how or where to store the results retrieved by the async call once it returns.\r\n\r\nSeveral solutions have been given in this thread. Perhaps the easiest way is to pass an object to the `foo()` method, and to store the results in a member of that object after the async call completes.\r\n\r\n    function foo(result) {\r\n        $.ajax({\r\n            url: &#39;...&#39;,\r\n            success: function(response) {\r\n                result.response = response;   // Store the async result\r\n            }\r\n        });\r\n    }\r\n    \r\n    var result = { response: null };   // Object to hold the async result\r\n    foo(result);                       // Returns before the async completes\r\n\r\nNote that the call to `foo()` will still return nothing useful. However, the result of the async call will now be stored in `result.response`."},{"score":39,"body_markdown":"We find ourselves in a universe which appears to progress along a dimension we call &quot;time&quot;. We don&#39;t really understand what time is, but we have developed abstractions and vocabulary that let us reason and talk about it: &quot;past&quot;, &quot;present&quot;, &quot;future&quot;, &quot;before&quot;, &quot;after&quot;.\r\n\r\nThe computer systems we build--more and more--have time as an important dimension. Certain things are set up to happen in the future. Then other things need to happen after those first things eventually occur. This is the basic notion called &quot;asynchronicity&quot;. In our increasingly networked world, the most common case of asynchronicity is waiting for some remote system to respond to some request.\r\n\r\nConsider an example. You call the milkman and order some milk. When it comes, you want to put it in your coffee. You can&#39;t put the milk in your coffee right now, because it is not here yet. You have to wait for it to come before putting it in your coffee. In other words, the following won&#39;t work:\r\n\r\n    var milk = order_milk();\r\n    put_in_coffee(milk);\r\n\r\nBecause JS has no way to know that it needs to **wait** for `order_milk` to finish before it executes `put_in_coffee`. In other words, it does not know that `order_milk` is **asynchronous**--is something that is not going to result in milk until some future time. JS, and other declarative languages execute one statement after another without waiting.\r\n\r\nThe classic JS approach to this problem, taking advantage of the fact that JS supports functions as first-class objects which can be passed around, is to pass a function as a parameter to the asynchronous request, which it will then invoke when it has completed its task sometime in the future. That is the &quot;callback&quot; approach. It looks like this:\r\n\r\n    order_milk(put_in_coffee);\r\n\r\n`order_milk` kicks off, orders the milk, then, when and only when it arrives, it invokes `put_in_coffee`.\r\n\r\nThe problem with this callback approach is that it pollutes the normal semantics of a function reporting its result with `return`; instead, functions must not reports their results by calling a callback given as a parameter. Also, this approach can rapidly become unwieldy when dealing with longer sequences of events. For example, let&#39;s say that I want to wait for the milk to be put in the coffee, and then and only then perform a third step, namely drinking the coffee. I end up needing to write something like this:\r\n\r\n    order_milk(function(milk) { put_in_coffee(milk, drink_coffee); }\r\n\r\nwhere I am passing to `put_in_coffee` both the milk to put in it, and also the action (`drink_coffee`) to execute once the milk has been put in. Such code becomes hard to write, and read, and debug.\r\n\r\nIn this case, we could rewrite the code in the question as:\r\n\r\n    var answer;\r\n    $.ajax(&#39;/foo.json&#39;) . done(function(response) {\r\n      callback(response.data);\r\n    });\r\n\r\n    function callback(data) {\r\n      console.log(data);\r\n    }\r\n\r\n### Enter promises \r\n\r\nThis was the motivation for the notion of a &quot;promise&quot;, which is a particular type of value which represents a **future** or **asynchronous** outcome of some sort. It can represent something that already happened, or that is going to happen in the future, or might never happen at all. Promises have a single method, named `then`, to which you pass an action to be executed when the outcome the promise represents has been realized.\r\n\r\nIn the case of our milk and coffee, we design `order_milk` to return a promise for the milk arriving, then specify `put_in_coffee` as a `then` action, as follows:\r\n\r\n    order_milk() . then(put_in_coffee)\r\n\r\nOne advantage of this is that we can string these together to create sequences of future occurrences (&quot;chaining&quot;):\r\n\r\n    order_milk() . then(put_in_coffee) . then(drink_coffee)\r\n\r\nLet&#39;s apply promises to your particular problem. We will wrap our request logic inside a function, which returns a promise:\r\n\r\n    function get_data() {\r\n      return $.ajax(&#39;/foo.json&#39;);\r\n    }\r\n\r\nActually, all we&#39;ve done is added a `return` to the call to `$.ajax`. This works because jQuery&#39;s `$.ajax` already returns a kind of promise-like thing. (In practice, without getting into details, we would prefer to wrap this call so as for return a real promise, or use some alternative to `$.ajax` that does so.) Now, if we want to load the file and wait for it to finish and then do something, we can simply say \r\n\r\n    get_data() . then(do_something)\r\n\r\nfor instance,\r\n\r\n    get_data() . \r\n      then(function(data) { console.log(data); });\r\n\r\nWhen using promises, we end up passing lots of functions into `then`, so it&#39;s often helpful to use the more compact ES6-style arrow functions:\r\n\r\n    get_data() . \r\n      then(data =&gt; console.log(data));\r\n\r\n### The `async` keyword\r\n\r\nBut there&#39;s still something vaguely dissatisfying about having to write code one way if synchronous and a quite different way if asynchronous. For synchronous, we write\r\n\r\n    a();\r\n    b();\r\n\r\nbut if `a` is asynchronous, with promises we have to write\r\n\r\n    a() . then(b);\r\n\r\nAbove, we said, &quot;JS has no way to know that it needs to **wait** for the first call to finish before it executes the second&quot;. Wouldn&#39;t it be nice if there **was** some way to tell JS that? It turns out that there is--the `await` keyword, used inside a special type of function called an &quot;async&quot; function. This feature is part of the upcoming version of ES but is already available in transpilers such as Babel given the right presets. This allows us to simply write\r\n\r\n    async function morning_routine() {\r\n      var milk   = await order_milk();\r\n      var coffee = await put_in_coffee(milk);\r\n      await drink(coffee);\r\n    }\r\n\r\nIn your case, you would be able to write something like \r\n\r\n    async function foo() {\r\n      data = await get_data();\r\n      console.log(data);\r\n    }"},{"score":89,"body_markdown":"While promises and callbacks work fine in many situations, it is a pain in the rear to express something like:\r\n\r\n    if (!name) {\r\n      name = async1();\r\n    }\r\n    async2(name);\r\n\r\nYou&#39;d end up going through `async1`; check if `name` is undefined or not and call the callback accordingly.\r\n\r\n    async1(name, callback) {\r\n      if (name)\r\n        callback(name)\r\n      else {\r\n        doSomething(callback)\r\n      }\r\n    }\r\n    \r\n    async1(name, async2)\r\n\r\nWhile it is _okay_ in small examples it gets annoying when you have a lot of similar cases and error handling involved.\r\n\r\n`Fibers` helps in solving the issue.\r\n\r\n    var Fiber = require(&#39;fibers&#39;)\r\n\r\n    function async1(container) {\r\n      var current = Fiber.current\r\n      var result\r\n      doSomething(function(name) {\r\n        result = name\r\n        fiber.run()\r\n      })\r\n      Fiber.yield()\r\n      return result\r\n    }\r\n    \r\n    Fiber(function() {\r\n      var name\r\n      if (!name) {\r\n        name = async1()\r\n      }\r\n      async2(name)\r\n      // Make any number of async calls from here\r\n    }\r\n\r\nYou can checkout the project [here](https://github.com/laverdet/node-fibers)."},{"score":88,"body_markdown":"The following example I have written shows how to\r\n\r\n - Handle asynchronous HTTP calls;\r\n - Wait for response from each API call;\r\n - Use [Promise][1] pattern;\r\n - Use [Promise.all][2] pattern to join multiple HTTP calls;\r\n\r\nThis working example is self-contained. It will define a simple request object that uses the window `XMLHttpRequest` object to make calls. It will define a simple function to wait for a bunch of promises to be completed.\r\n\r\nContext. The example is querying the [Spotify Web API][3] endpoint in order to search for `playlist` objects for a given set of query strings:\r\n\r\n    [\r\n     &quot;search?type=playlist&amp;q=%22doom%20metal%22&quot;,\r\n     &quot;search?type=playlist&amp;q=Adele&quot;\r\n    ]\r\n\r\nFor each item, a new Promise will fire a block - `ExecutionBlock`, parse the result, schedule a new set of promises based on the result array, that is a list of Spotify `user` objects and execute the new HTTP call within the `ExecutionProfileBlock` asynchronously.\r\n\r\nYou can then see a nested Promise structure, that lets you spawn multiple and completely asynchronous nested HTTP calls, and join the results from each subset of calls through `Promise.all`.\r\n\r\n**NOTE**\r\nRecent Spotify `search` APIs will require an access token to be specified in the request headers:\r\n\r\n    -H &quot;Authorization: Bearer {your access token}&quot; \r\n\r\nSo, you to run the following example you need to put your access token in the request headers:\r\n\r\n&lt;!-- begin snippet: js hide: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var spotifyAccessToken = &quot;YourSpotifyAccessToken&quot;;\r\n    var console = {\r\n        log: function(s) {\r\n            document.getElementById(&quot;console&quot;).innerHTML += s + &quot;&lt;br/&gt;&quot;\r\n        }\r\n    }\r\n\r\n    // Simple XMLHttpRequest\r\n    // based on https://davidwalsh.name/xmlhttprequest\r\n    SimpleRequest = {\r\n        call: function(what, response) {\r\n            var request;\r\n            if (window.XMLHttpRequest) { // Mozilla, Safari, ...\r\n                request = new XMLHttpRequest();\r\n            } else if (window.ActiveXObject) { // Internet Explorer\r\n                try {\r\n                    request = new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;);\r\n                }\r\n                catch (e) {\r\n                    try {\r\n                      request = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);\r\n                    } catch (e) {}\r\n                }\r\n            }\r\n\r\n            // State changes\r\n            request.onreadystatechange = function() {\r\n                if (request.readyState === 4) { // Done\r\n                    if (request.status === 200) { // Complete\r\n                        response(request.responseText)\r\n                    }\r\n                    else\r\n                        response();\r\n                }\r\n            }\r\n            request.open(&#39;GET&#39;, what, true);\r\n            request.setRequestHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + spotifyAccessToken);\r\n            request.send(null);\r\n        }\r\n    }\r\n\r\n    //PromiseAll\r\n    var promiseAll = function(items, block, done, fail) {\r\n        var self = this;\r\n        var promises = [],\r\n                       index = 0;\r\n        items.forEach(function(item) {\r\n            promises.push(function(item, i) {\r\n                return new Promise(function(resolve, reject) {\r\n                    if (block) {\r\n                        block.apply(this, [item, index, resolve, reject]);\r\n                    }\r\n                });\r\n            }(item, ++index))\r\n        });\r\n        Promise.all(promises).then(function AcceptHandler(results) {\r\n            if (done) done(results);\r\n        }, function ErrorHandler(error) {\r\n            if (fail) fail(error);\r\n        });\r\n    }; //promiseAll\r\n\r\n    // LP: deferred execution block\r\n    var ExecutionBlock = function(item, index, resolve, reject) {\r\n        var url = &quot;https://api.spotify.com/v1/&quot;\r\n        url += item;\r\n        console.log( url )\r\n        SimpleRequest.call(url, function(result) {\r\n            if (result) {\r\n\r\n                var profileUrls = JSON.parse(result).playlists.items.map(function(item, index) {\r\n                    return item.owner.href;\r\n                })\r\n                resolve(profileUrls);\r\n            }\r\n            else {\r\n                reject(new Error(&quot;call error&quot;));\r\n            }\r\n        })\r\n    }\r\n\r\n    arr = [\r\n        &quot;search?type=playlist&amp;q=%22doom%20metal%22&quot;,\r\n        &quot;search?type=playlist&amp;q=Adele&quot;\r\n    ]\r\n\r\n    promiseAll(arr, function(item, index, resolve, reject) {\r\n        console.log(&quot;Making request [&quot; + index + &quot;]&quot;)\r\n        ExecutionBlock(item, index, resolve, reject);\r\n    }, function(results) { // Aggregated results\r\n\r\n        console.log(&quot;All profiles received &quot; + results.length);\r\n        //console.log(JSON.stringify(results[0], null, 2));\r\n\r\n        ///// promiseall again\r\n\r\n        var ExecutionProfileBlock = function(item, index, resolve, reject) {\r\n            SimpleRequest.call(item, function(result) {\r\n                if (result) {\r\n                    var obj = JSON.parse(result);\r\n                    resolve({\r\n                        name: obj.display_name,\r\n                        followers: obj.followers.total,\r\n                        url: obj.href\r\n                    });\r\n                } //result\r\n            })\r\n        } //ExecutionProfileBlock\r\n\r\n        promiseAll(results[0], function(item, index, resolve, reject) {\r\n            //console.log(&quot;Making request [&quot; + index + &quot;] &quot; + item)\r\n            ExecutionProfileBlock(item, index, resolve, reject);\r\n        }, function(results) { // aggregated results\r\n            console.log(&quot;All response received &quot; + results.length);\r\n            console.log(JSON.stringify(results, null, 2));\r\n        }\r\n\r\n        , function(error) { // Error\r\n            console.log(error);\r\n        })\r\n\r\n        /////\r\n\r\n      },\r\n      function(error) { // Error\r\n          console.log(error);\r\n      });\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;div id=&quot;console&quot; /&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nI have extensively discussed this solution [here][4].\r\n\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Futures_and_promises\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\r\n  [3]: https://developer.spotify.com/web-api/endpoint-reference/\r\n  [4]: https://stackoverflow.com/questions/36536245/how-to-search-for-a-user-by-name-using-spotify-web-api/36537774#36537774"},{"score":84,"body_markdown":"Short answer is, **you have to implement a callback like this:**\r\n\r\n    function callback(response) {\r\n        // Here you can do what ever you want with the response object.\r\n        console.log(response);\r\n    }\r\n\r\n    $.ajax({\r\n        url: &quot;...&quot;,\r\n        success: callback\r\n    });"},{"score":70,"body_markdown":"You can use this custom library (written using Promise) to make a remote call.\r\n\r\n    function $http(apiConfig) {\r\n        return new Promise(function (resolve, reject) {\r\n            var client = new XMLHttpRequest();\r\n            client.open(apiConfig.method, apiConfig.url);\r\n            client.send();\r\n            client.onload = function () {\r\n                if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) {\r\n                    // Performs the function &quot;resolve&quot; when this.status is equal to 2xx.\r\n                    // Your logic here.\r\n                    resolve(this.response);\r\n                }\r\n                else {\r\n                    // Performs the function &quot;reject&quot; when this.status is different than 2xx.\r\n                    reject(this.statusText);\r\n                }\r\n            };\r\n            client.onerror = function () {\r\n                reject(this.statusText);\r\n            };\r\n        });\r\n    }\r\n\r\nSimple usage example:\r\n\r\n    $http({\r\n        method: &#39;get&#39;,\r\n        url: &#39;google.com&#39;\r\n    }).then(function(response) {\r\n        console.log(response);\r\n    }, function(error) {\r\n        console.log(error)\r\n    });\r\n"},{"score":113,"body_markdown":"**Have a look at this example:**\r\n\r\n\r\n    var app = angular.module(&#39;plunker&#39;, []);\r\n\r\n    app.controller(&#39;MainCtrl&#39;, function($scope,$http) {\r\n\r\n        var getJoke = function(){\r\n            return $http.get(&#39;http://api.icndb.com/jokes/random&#39;).then(function(res){\r\n                return res.data.value;  \r\n            });\r\n        }\r\n \r\n        getJoke().then(function(res) {\r\n            console.log(res.joke);\r\n        });\r\n    });\r\n\r\nAs you can see `getJoke` is **returning a** resolved **promise** (it is resolved when returning `res.data.value`). So you wait until the **$http.get** request is completed and then **console.log(res.joke)** is executed (as a normal asynchronous flow).\r\n\r\n**This is the plnkr:**\r\n\r\nhttp://embed.plnkr.co/XlNR7HpCaIhJxskMJfSg/\r\n\r\n**ES6 way (async - await)**\r\n    \r\n    (function(){\r\n      async function getJoke(){\r\n        let response = await fetch(&#39;http://api.icndb.com/jokes/random&#39;);\r\n        let data = await response.json();\r\n        return data.value;\r\n      }\r\n  \r\n      getJoke().then((joke) =&gt; {\r\n        console.log(joke);\r\n      });\r\n    })();\r\n"},{"score":231,"body_markdown":"I will answer with a horrible-looking, hand-drawn comic. The second image is the reason why `result` is `undefined` in your code example.\r\n\r\n[![enter image description here][1]][1]\r\n\r\n\r\n  [1]: http://i.imgur.com/v5ksbBC.jpg"},{"score":39,"body_markdown":"## Here are some approaches to work with asynchronous requests:\n\n 1. [Browser Promise object][1]\n 2. [Q][2] - A promise library for JavaScript\n 3. [A+ Promises.js][3]\n 4. [jQuery deferred][4]\n 5. [XMLHttpRequest API][5]\n 6. Using callback concept - As implementation in first answer\n\n### Example: jQuery deferred implementation to work with multiple requests\n\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\n\n&lt;!-- language: lang-js --&gt;\n\n    var App = App || {};\n\n    App = {\n        getDataFromServer: function(){\n\n          var self = this,\n                     deferred = $.Deferred(),\n                     requests = [];\n\n          requests.push($.getJSON(&#39;request/ajax/url/1&#39;));\n          requests.push($.getJSON(&#39;request/ajax/url/2&#39;));\n\n          $.when.apply(jQuery, requests).done(function(xhrResponse) {\n            return deferred.resolve(xhrResponse.result);\n          });\n          return deferred;\n        },\n\n        init: function(){\n\n            this.getDataFromServer().done(_.bind(function(resp1, resp2) {\n\n               // Do the operations which you wanted to do when you\n               // get a response from Ajax, for example, log response.\n            }, this));\n        }\n    };\n    App.init();\n\n&lt;!-- end snippet --&gt;\n\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n  [2]: https://github.com/kriskowal/q\n  [3]: https://www.promisejs.org/\n  [4]: https://api.jquery.com/jquery.deferred/\n  [5]: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n\n"},{"score":36,"body_markdown":"Use a `callback()` function inside the `foo()` success.\r\nTry in this way. It is simple and easy to understand. &amp;nbsp;\r\n\r\n    var lat = &quot;&quot;;\r\n  \tvar lon = &quot;&quot;;\r\n    function callback(data) {\r\n\t\tlat = data.lat;\r\n\t\tlon = data.lon;\r\n\t}\r\n    function getLoc() {\r\n\t    var url = &quot;http://ip-api.com/json&quot;\r\n\t    $.getJSON(url, function(data) {\r\n\t        callback(data);\r\n\t    });\r\n\t}\r\n\r\n\tgetLoc();\r\n\r\n"},{"score":159,"body_markdown":"Most of the answers here give useful suggestions for when you have a single async operation, but sometimes, this comes up when you need to do an asynchronous operation for *each* entry in an array or other list-like structure. The temptation is to do this:\r\n\r\n    // WRONG\r\n    var results = [];\r\n    theArray.forEach(function(entry) {\r\n        doSomethingAsync(entry, function(result) {\r\n            results.push(result);\r\n        });\r\n    });\r\n    console.log(results); // E.g., using them, returning them, etc.\r\n\r\nExample:\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    // WRONG\r\n    var theArray = [1, 2, 3];\r\n    var results = [];\r\n    theArray.forEach(function(entry) {\r\n        doSomethingAsync(entry, function(result) {\r\n            results.push(result);\r\n        });\r\n    });\r\n    console.log(&quot;Results:&quot;, results); // E.g., using them, returning them, etc.\r\n\r\n    function doSomethingAsync(value, callback) {\r\n        console.log(&quot;Starting async operation for &quot; + value);\r\n        setTimeout(function() {\r\n            console.log(&quot;Completing async operation for &quot; + value);\r\n            callback(value * 2);\r\n        }, Math.floor(Math.random() * 200));\r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper {\r\n      max-height: 100% !important;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThe reason that doesn&#39;t work is that the callbacks from `doSomethingAsync` haven&#39;t run yet by the time you&#39;re trying to use the results.\r\n\r\nSo, if you have an array (or list of some kind) and want to do async operations for each entry, you have two options: Do the operations in parallel (overlapping), or in series (one after another in sequence).\r\n\r\n### Parallel\r\n\r\nYou can start all of them and keep track of how many callbacks you&#39;re expecting, and then use the results when you&#39;ve gotten that many callbacks:\r\n\r\n    var results = [];\r\n    var expecting = theArray.length;\r\n    theArray.forEach(function(entry, index) {\r\n        doSomethingAsync(entry, function(result) {\r\n            results[index] = result;\r\n            if (--expecting === 0) {\r\n                // Done!\r\n                console.log(&quot;Results:&quot;, results); // E.g., using the results\r\n            }\r\n        });\r\n    });\r\n\r\nExample:\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    var theArray = [1, 2, 3];\r\n    var results = [];\r\n    var expecting = theArray.length;\r\n    theArray.forEach(function(entry, index) {\r\n        doSomethingAsync(entry, function(result) {\r\n            results[index] = result;\r\n            if (--expecting === 0) {\r\n                // Done!\r\n                console.log(&quot;Results:&quot;, results); // E.g., using the results\r\n            }\r\n        });\r\n    });\r\n\r\n    function doSomethingAsync(value, callback) {\r\n        console.log(&quot;Starting async operation for &quot; + value);\r\n        setTimeout(function() {\r\n            console.log(&quot;Completing async operation for &quot; + value);\r\n            callback(value * 2);\r\n        }, Math.floor(Math.random() * 200));\r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper {\r\n      max-height: 100% !important;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n*(We could do away with `expecting` and just use `results.length === theArray.length`, but that leaves us open to the possibility that `theArray` is changed while the calls are outstanding...)*\r\n\r\nNotice how we use the `index` from `forEach` to save the result in `results` in the same position as the entry it relates to, even if the results arrive out of order (since async calls don&#39;t necessarily complete in the order in which they were started).\r\n\r\nBut what if you need to *return* those results from a function? As the other answers have pointed out, you can&#39;t; you have to have your function accept and call a callback (or return a [Promise][1]). Here&#39;s a callback version:\r\n\r\n    function doSomethingWith(theArray, callback) {\r\n        var results = [];\r\n        var expecting = theArray.length;\r\n        theArray.forEach(function(entry, index) {\r\n            doSomethingAsync(entry, function(result) {\r\n                results[index] = result;\r\n                if (--expecting === 0) {\r\n                    // Done!\r\n                    callback(results);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    doSomethingWith(theArray, function(results) {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\nExample:\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function doSomethingWith(theArray, callback) {\r\n        var results = [];\r\n        var expecting = theArray.length;\r\n        theArray.forEach(function(entry, index) {\r\n            doSomethingAsync(entry, function(result) {\r\n                results[index] = result;\r\n                if (--expecting === 0) {\r\n                    // Done!\r\n                    callback(results);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    doSomethingWith([1, 2, 3], function(results) {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\n    function doSomethingAsync(value, callback) {\r\n        console.log(&quot;Starting async operation for &quot; + value);\r\n        setTimeout(function() {\r\n            console.log(&quot;Completing async operation for &quot; + value);\r\n            callback(value * 2);\r\n        }, Math.floor(Math.random() * 200));\r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper {\r\n      max-height: 100% !important;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nOr here&#39;s a version returning a `Promise` instead:\r\n\r\n    function doSomethingWith(theArray) {\r\n        return new Promise(function(resolve) {\r\n            var results = [];\r\n            var expecting = theArray.length;\r\n            theArray.forEach(function(entry, index) {\r\n                doSomethingAsync(entry, function(result) {\r\n                    results[index] = result;\r\n                    if (--expecting === 0) {\r\n                        // Done!\r\n                        resolve(results);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    }\r\n    doSomethingWith(theArray).then(function(results) {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\n*Of course, if `doSomethingAsync` passed us errors, we&#39;d use `reject` to reject the promise when we got an error.)*\r\n\r\nExample:\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function doSomethingWith(theArray) {\r\n        return new Promise(function(resolve) {\r\n            var results = [];\r\n            var expecting = theArray.length;\r\n            theArray.forEach(function(entry, index) {\r\n                doSomethingAsync(entry, function(result) {\r\n                    results[index] = result;\r\n                    if (--expecting === 0) {\r\n                        // Done!\r\n                        resolve(results);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    }\r\n    doSomethingWith([1, 2, 3]).then(function(results) {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\n    function doSomethingAsync(value, callback) {\r\n        console.log(&quot;Starting async operation for &quot; + value);\r\n        setTimeout(function() {\r\n            console.log(&quot;Completing async operation for &quot; + value);\r\n            callback(value * 2);\r\n        }, Math.floor(Math.random() * 200));\r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper {\r\n      max-height: 100% !important;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n*(Or alternately, you could make a wrapper for `doSomethingAsync` that returns a promise, and then do the below...)*\r\n\r\nIf `doSomethingAsync` gives you a [Promise][1], you can use [`Promise.all`][2]:\r\n\r\n    function doSomethingWith(theArray) {\r\n        return Promise.all(theArray.map(function(entry) {\r\n            return doSomethingAsync(entry);\r\n        }));\r\n    }\r\n    doSomethingWith(theArray).then(function(results) {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\nIf you know that `doSomethingAsync` will ignore a second and third argument, you can just pass it directly to `map` (`map` calls its callback with three arguments, but most people only use the first most of the time):\r\n\r\n    function doSomethingWith(theArray) {\r\n        return Promise.all(theArray.map(doSomethingAsync));\r\n    }\r\n    doSomethingWith(theArray).then(function(results) {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\nExample:\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function doSomethingWith(theArray) {\r\n        return Promise.all(theArray.map(doSomethingAsync));\r\n    }\r\n    doSomethingWith([1, 2, 3]).then(function(results) {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\n    function doSomethingAsync(value) {\r\n        console.log(&quot;Starting async operation for &quot; + value);\r\n        return new Promise(function(resolve) {\r\n            setTimeout(function() {\r\n                console.log(&quot;Completing async operation for &quot; + value);\r\n                resolve(value * 2);\r\n            }, Math.floor(Math.random() * 200));\r\n        });\r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper {\r\n      max-height: 100% !important;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nNote that `Promise.all` resolves its promise with an array of the results of all of the promises you give it when they are all resolved, or rejects its promise when the *first* of the promises you give it rejects.\r\n\r\n### Series\r\n\r\nSuppose you don&#39;t want the operations to be in parallel? If you want to run them one after another, you need to wait for each operation to complete before you start the next. Here&#39;s an example of a function that does that and calls a callback with the result:\r\n\r\n    function doSomethingWith(theArray, callback) {\r\n        var results = [];\r\n        doOne(0);\r\n        function doOne(index) {\r\n            if (index &lt; theArray.length) {\r\n                doSomethingAsync(theArray[index], function(result) {\r\n                    results.push(result);\r\n                    doOne(index + 1);\r\n                });\r\n            } else {\r\n                // Done!\r\n                callback(results);\r\n            }\r\n        }\r\n    }\r\n    doSomethingWith(theArray, function(results) {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\n*(Since we&#39;re doing the work in series, we can just use `results.push(result)` since we know we won&#39;t get results out of order. In the above we could have used `results[index] = result;`, but in some of the following examples we don&#39;t have an index to use.)*\r\n\r\nExample:\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function doSomethingWith(theArray, callback) {\r\n        var results = [];\r\n        doOne(0);\r\n        function doOne(index) {\r\n            if (index &lt; theArray.length) {\r\n                doSomethingAsync(theArray[index], function(result) {\r\n                    results.push(result);\r\n                    doOne(index + 1);\r\n                });\r\n            } else {\r\n                // Done!\r\n                callback(results);\r\n            }\r\n        }\r\n    }\r\n    doSomethingWith([1, 2, 3], function(results) {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\n    function doSomethingAsync(value, callback) {\r\n        console.log(&quot;Starting async operation for &quot; + value);\r\n        setTimeout(function() {\r\n            console.log(&quot;Completing async operation for &quot; + value);\r\n            callback(value * 2);\r\n        }, Math.floor(Math.random() * 200));\r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper {\r\n      max-height: 100% !important;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n*(Or, again, build a wrapper for `doSomethingAsync` that gives you a promise and do the below...)*\r\n\r\nIf `doSomethingAsync` gives you a Promise, if you can use ES2017+ syntax (perhaps with a transpiler like [Babel](http://babeljs.io)), you can use an [`async` function][3] with [`for-of`][4] and [`await`][5]:\r\n\r\n    async function doSomethingWith(theArray) {\r\n        const results = [];\r\n        for (const entry of theArray) {\r\n            results.push(await doSomethingAsync(entry));\r\n        }\r\n        return results;\r\n    }\r\n    doSomethingWith(theArray).then(results =&gt; {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\nExample:\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    async function doSomethingWith(theArray) {\r\n        const results = [];\r\n        for (const entry of theArray) {\r\n            results.push(await doSomethingAsync(entry));\r\n        }\r\n        return results;\r\n    }\r\n    doSomethingWith([1, 2, 3]).then(function(results) {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\n    function doSomethingAsync(value) {\r\n        console.log(&quot;Starting async operation for &quot; + value);\r\n        return new Promise(function(resolve) {\r\n            setTimeout(function() {\r\n                console.log(&quot;Completing async operation for &quot; + value);\r\n                resolve(value * 2);\r\n            }, Math.floor(Math.random() * 200));\r\n        });\r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper {\r\n      max-height: 100% !important;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nIf you can&#39;t use ES2017+ syntax (yet), you can use a variation on the [&quot;Promise reduce&quot; pattern][6] (this is more complex than the usual Promise reduce because we&#39;re not passing the result from one into the next, but instead gathering up their results in an array):\r\n\r\n    function doSomethingWith(theArray) {\r\n        return theArray.reduce(function(p, entry) {\r\n            return p.then(function(results) {\r\n                return doSomethingAsync(entry).then(function(result) {\r\n                    results.push(result);\r\n                    return results;\r\n                });\r\n            });\r\n        }, Promise.resolve([]));\r\n    }\r\n    doSomethingWith(theArray).then(function(results) {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\nExample:\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function doSomethingWith(theArray) {\r\n        return theArray.reduce(function(p, entry) {\r\n            return p.then(function(results) {\r\n                return doSomethingAsync(entry).then(function(result) {\r\n                    results.push(result);\r\n                    return results;\r\n                });\r\n            });\r\n        }, Promise.resolve([]));\r\n    }\r\n    doSomethingWith([1, 2, 3]).then(function(results) {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\n    function doSomethingAsync(value) {\r\n        console.log(&quot;Starting async operation for &quot; + value);\r\n        return new Promise(function(resolve) {\r\n            setTimeout(function() {\r\n                console.log(&quot;Completing async operation for &quot; + value);\r\n                resolve(value * 2);\r\n            }, Math.floor(Math.random() * 200));\r\n        });\r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper {\r\n      max-height: 100% !important;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n...which is less cumbersome with [ES2015+ arrow functions][7]:\r\n\r\n    function doSomethingWith(theArray) {\r\n        return theArray.reduce((p, entry) =&gt; p.then(results =&gt; doSomethingAsync(entry).then(result =&gt; {\r\n            results.push(result);\r\n            return results;\r\n        })), Promise.resolve([]));\r\n    }\r\n    doSomethingWith(theArray).then(results =&gt; {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\nExample:\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function doSomethingWith(theArray) {\r\n        return theArray.reduce((p, entry) =&gt; p.then(results =&gt; doSomethingAsync(entry).then(result =&gt; {\r\n            results.push(result);\r\n            return results;\r\n        })), Promise.resolve([]));\r\n    }\r\n    doSomethingWith([1, 2, 3]).then(function(results) {\r\n        console.log(&quot;Results:&quot;, results);\r\n    });\r\n\r\n    function doSomethingAsync(value) {\r\n        console.log(&quot;Starting async operation for &quot; + value);\r\n        return new Promise(function(resolve) {\r\n            setTimeout(function() {\r\n                console.log(&quot;Completing async operation for &quot; + value);\r\n                resolve(value * 2);\r\n            }, Math.floor(Math.random() * 200));\r\n        });\r\n    }\r\n\r\n&lt;!-- language: lang-css --&gt;\r\n\r\n    .as-console-wrapper {\r\n      max-height: 100% !important;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of\r\n  [5]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await\r\n  [6]: https://stackoverflow.com/questions/43433643/javascript-how-do-i-reduce-multiple-promise-all\r\n  [7]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\r\n"},{"score":112,"body_markdown":"This is one of the places which **two ways data binding** or **store concept** that&#39;s used in many new JavaScript frameworks will work great for you...\r\n\r\nSo if you are using **Angular, React** or any other frameworks which do **two ways data binding** or **store concept** this issue is simply fixed for you, so in easy word, your result is `undefined` at the first stage, so you have got `result = undefined` before you receive the data, then as soon as you get the result, it will be updated and get assigned to the new value which response of your Ajax call...\r\n\r\nBut how you can do it in pure **javascript** or **jQuery** for example as you asked in this question?\r\n\r\nYou can use a **callback**, **promise** and recently **observable** to handle it for you, for example in promises we have some function like `success()` or `then()` which will be executed when your data is ready for you, same with callback or **subscribe** function on **observable**.\r\n\r\nFor example in your case which you are using **jQuery**, you can do something like this:\r\n\r\n  \r\n\r\n    $(document).ready(function(){\r\n        function foo() {\r\n            $.ajax({url: &quot;api/data&quot;, success: function(data){\r\n                fooDone(data); //after we have data, we pass it to fooDone\r\n            }});\r\n        };\r\n    \r\n        function fooDone(data) {\r\n            console.log(data); //fooDone has the data and console.log it\r\n        };\r\n        \r\n        foo(); //call happens here\r\n    });\r\n\r\nFor more information study about **promises** and **observables** which are newer ways to do this async stuffs."},{"score":70,"body_markdown":"Another solution is to execute code via sequential executor [nsynjs][1].\r\n\r\nIf underlying function is promisified\r\n-------------------------------------\r\n\r\nnsynjs will evaluate all promises sequentially, and put promise result into `data` property:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function synchronousCode() {\r\n\r\n        var getURL = function(url) {\r\n            return window.fetch(url).data.text().data;\r\n        };\r\n        \r\n        var url = &#39;https://ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js&#39;;\r\n        console.log(&#39;received bytes:&#39;,getURL(url).length);\r\n        \r\n    };\r\n\r\n    nsynjs.run(synchronousCode,{},function(){\r\n        console.log(&#39;synchronousCode done&#39;);\r\n    });\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://rawgit.com/amaksr/nsynjs/master/nsynjs.js&quot;&gt;&lt;/script&gt;\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n\r\nIf underlying function is not promisified\r\n-------------------------------------\r\n\r\nStep 1. Wrap function with callback into nsynjs-aware wrapper (if it has promisified version, you can skip this step):\r\n\r\n\tvar ajaxGet = function (ctx,url) {\r\n\t\tvar res = {};\r\n\t\tvar ex;\r\n\t\t$.ajax(url)\r\n\t\t.done(function (data) {\r\n\t\t\tres.data = data;\r\n\t\t})\r\n\t\t.fail(function(e) {\r\n\t\t\tex = e;\r\n\t\t})\r\n\t\t.always(function() {\r\n\t\t\tctx.resume(ex);\r\n\t\t});\r\n\t\treturn res;\r\n\t};\r\n\tajaxGet.nsynjsHasCallback = true;\r\n\r\nStep 2. Put synchronous logic into function:\r\n\r\n\tfunction process() {\r\n\t\tconsole.log(&#39;got data:&#39;, ajaxGet(nsynjsCtx, &quot;data/file1.json&quot;).data);\r\n\t}\r\n\r\nStep 3. Run function in synchronous manner via nsynjs:\r\n\r\n\tnsynjs.run(process,this,function () {\r\n\t\tconsole.log(&quot;synchronous function finished&quot;);\r\n\t});\r\n\r\nNsynjs will evaluate all operators and expressions step-by-step, pausing execution in case if result of some slow function is not ready.\r\n\r\n\r\n\r\n\r\nMore examples here: https://github.com/amaksr/nsynjs/tree/master/examples\r\n\r\n  [1]: https://github.com/amaksr/nsynjs"},{"score":82,"body_markdown":"# 2017 answer: you can now do exactly what you want in every current browser and node \r\n\r\nThis is quite simple:\r\n\r\n - Return a Promise\r\n - Use the [&#39;await&#39;](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await), which will tell JavaScript to await the promise to be resolved into a value (like the HTTP response)\r\n - Add the [&#39;async&#39;](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) keyword to the parent function\r\n\r\nHere&#39;s a working version of your code:\r\n\r\n    (async function(){\r\n\r\n    var response = await superagent.get(&#39;...&#39;)\r\n    console.log(response)\r\n\r\n    })()\r\n\r\n[await is supported in all current browsers and node 8](http://caniuse.com/#search=await)"},{"score":28,"body_markdown":"Of course there are many approaches like synchronous request, promise, but from my experience I think you should use the callback approach. It&#39;s natural to asynchronous behavior of Javascript.\r\nSo, your code snippet can be rewrite a little different:\r\n\r\n    function foo() {\r\n        var result;\r\n    \r\n        $.ajax({\r\n            url: &#39;...&#39;,\r\n            success: function(response) {\r\n                myCallback(response);\r\n            }\r\n        });\r\n    \r\n        return result;\r\n    }\r\n    \r\n    function myCallback(response) {\r\n        // Does something.\r\n    }"},{"score":15,"body_markdown":"**Let&#39;s see the forest first before looking at the trees.**\r\n\r\nThere are many informative answers with great details here, I won&#39;t repeat any of them. The key to programming in JavaScript is having first the **correct mental model** of overall execution.\r\n\r\n 1. Your entry point(s) is executed as the result of an event. For\r\n    example, a script tag with code is loaded into the browser.\r\n    (Accordingly, this is why you may need to be concerned with the\r\n    readiness of the page to run your code if it requires dom elements\r\n    to be constructed first, etc.)\r\n 2. Your code executes to completion--however many asynchronous calls it\r\n    makes--without executing **any** of your callbacks, including XHR\r\n    requests, set timeouts, dom event handlers, etc. Each of those callbacks waiting to be executed will sit in a queue, waiting their turn to be run after other events that fired have all finished execution.\r\n 3. Each individual callback to an XHR request, set timeout or dom\r\n    the event once invoked will then run to completion.\r\n\r\nThe good news is that if you understand this point well, you will never have to worry about race conditions. You should first and foremost thing of how you want to organize your code as essentially the response to different discrete events, and how you want to thread them together into a logical sequence.  You can use promises or higher level new async/await as tools to that end, or you can roll your own.\r\n\r\nBut you shouldn&#39;t use any tactical tools to solve a problem until you are comfortable with the actual problem domain. Draw a map of these dependencies to know what needs to run when. Attempting an ad-hoc approach to all these callbacks is just not going to serve you well.\r\n"},{"score":105,"body_markdown":"It&#39;s a very common issue we face while struggling with the &#39;mysteries&#39; of JavaScript. Let me try demystifying this mystery today.\r\n\r\nLet&#39;s start with a simple JavaScript function:\r\n\r\n    function foo(){\r\n    // do something \r\n     return &#39;wohoo&#39;;\r\n    }\r\n    \r\n    let bar = foo(); // bar is &#39;wohoo&#39; here\r\n\r\n\r\nThat&#39;s a simple synchronous function call (where each line of code is &#39;finished with its job&#39; before the next one in sequence), and the result is same as expected.\r\n\r\nNow let&#39;s add a bit of twist, by introducing little delay in our function, so that all lines of code are not &#39;finished&#39; in sequence. Thus, it will emulate the asynchronous behavior of function :\r\n\r\n    function foo(){\r\n     setTimeout( ()=&gt;{\r\n       return &#39;wohoo&#39;;\r\n      }, 1000 )\r\n    }\r\n    \r\n    let bar = foo() // bar is undefined here\r\n\r\nSo there you go, that delay just broke the functionality we expected! But what exactly happened ? Well, it&#39;s actually pretty logical if you look at the code. the function `foo()`, upon execution, returns nothing (thus returned value is `undefined`), but it does start a timer, which executes a function after 1s to return &#39;wohoo&#39;. But as you can see, the value that&#39;s assigned to bar is the immediately returned stuff from foo(), which is nothing i.e. just `undefined`.\r\n\r\n**So, how do we tackle this issue?**\r\n\r\nLet&#39;s ask our function for a **PROMISE**.\r\nPromise is really about what it means : it means that the function guarantees you to provide with any output it gets in future. so let&#39;s see it in action for our little problem above : \r\n\r\n    function foo(){\r\n       return new Promise( (resolve, reject) =&gt; { // I want foo() to PROMISE me something\r\n        setTimeout ( function(){ \r\n          // promise is RESOLVED , when execution reaches this line of code\r\n           resolve(&#39;wohoo&#39;)// After 1 second, RESOLVE the promise with value &#39;wohoo&#39;\r\n        }, 1000 )\r\n      })\r\n    }\r\n\r\n    let bar ; \r\n    foo().then( res =&gt; {\r\n     bar = res;\r\n     console.log(bar) // will print &#39;wohoo&#39;\r\n    });\r\n\r\nThus, the summary is - to tackle the asynchronous functions like ajax based calls etc., you can use a promise to `resolve` the value (which you intend to return). Thus, in short you **resolve** value instead of **returning**, in asynchronous functions.\r\n\r\n## UPDATE (Promises with async/await)\r\n\r\nApart from using `then/catch` to work with promises, there exists one more approach. The idea is to *recognize an asynchronous function* and then *wait for the promises* to resolve, before moving to the next line of code. It&#39;s still just the `promises` under the hood, but with a different syntactical approach. To make things clearer, you can find a comparison below:\r\n\r\n### then/catch version:\r\n\r\n \r\n\r\n    function saveUsers(){\r\n         getUsers()\r\n          .then(users =&gt; {\r\n             saveSomewhere(users);\r\n          })\r\n          .catch(err =&gt; {\r\n              console.error(err);\r\n           })\r\n     }\r\n\r\n\r\n\r\n### async/await version:\r\n\r\n      async function saveUsers(){\r\n         try{\r\n            let users = await getUsers()\r\n            saveSomewhere(users);\r\n         }\r\n         catch(err){\r\n            console.error(err);\r\n         }\r\n      }\r\n\r\n\r\n"},{"score":29,"body_markdown":"The question was: \r\n\r\n&gt; How do I return the response from an asynchronous call?\r\n\r\n which CAN be interpreted as: \r\n\r\n&gt; How to make **asynchronous** code look **synchronous**?\r\n\r\nThe solution will be to avoid callbacks, and use a combination of **Promises** and **async/await**.\r\n\r\nI would like to give an example for a Ajax request. \r\n\r\n(Although it can be written in Javascript, I prefer to write it in Python, and compile it to Javascript using [Transcrypt][1]. It will be clear enough.)\r\n\r\n\r\n  [1]: https://github.com/QQuick/Transcrypt\r\n\r\nLets first enable JQuery usage, to have `$` available as `S`:\r\n\r\n    __pragma__ (&#39;alias&#39;, &#39;S&#39;, &#39;$&#39;)\r\n\r\nDefine a function which returns a **Promise**, in this case an Ajax call:\r\n\r\n    def read(url: str):\r\n        deferred = S.Deferred()\r\n        S.ajax({&#39;type&#39;: &quot;POST&quot;, &#39;url&#39;: url, &#39;data&#39;: { },\r\n            &#39;success&#39;: lambda d: deferred.resolve(d),\r\n            &#39;error&#39;: lambda e: deferred.reject(e)\r\n        })\r\n        return deferred.promise()\r\n    \r\nUse the **asynchronous** code as if it were **synchronous**:\r\n\r\n    async def readALot():\r\n        try:\r\n            result1 = await read(&quot;url_1&quot;)\r\n            result2 = await read(&quot;url_2&quot;)\r\n        except Exception:\r\n            console.warn(&quot;Reading a lot failed&quot;)\r\n\r\n"},{"score":19,"body_markdown":"Using ES2017 you should have this as the function declaration\r\n\r\n    async function foo() {\r\n    \tvar response = await $.ajax({url: &#39;...&#39;})\r\n        return response;\r\n    }\r\n\r\nAnd executing it like this.\r\n\r\n    (async function() {\r\n\t    try {\r\n\t\t    var result = await foo()\r\n\t\t    console.log(result)\r\n\t    } catch (e) {}\r\n    })()\r\nOr the Promise syntax\r\n\r\n    foo().then(response =&gt; {\r\n    \tconsole.log(response)\r\n    \r\n    }).catch(error =&gt; {\r\n    \tconsole.log(error)\r\n    \t\r\n    })\r\n\r\n"},{"score":80,"body_markdown":"&gt;  Js is a single threaded.\r\n\r\nBrowser can be divided into three parts:\r\n\r\n1)Event Loop\r\n\r\n2)Web API\r\n\r\n3)Event Queue\r\n\r\n\r\n\r\n\r\nEvent Loop runs for forever i.e kind of infinite loop.Event Queue is where all your function are pushed on some event(example:click) this is one by one carried out of queue and put into Event loop which execute this function and prepares it self for next one after first one is executed.This means Execution of one function doesn&#39;t starts till the function before it in queue is executed in event loop.\r\n\r\nNow let us think we pushed two functions in a queue one is for getting a data from server and another utilises that data.We pushed the serverRequest() function in queue first then utiliseData() function. serverRequest function goes in event loop and makes a call to server as we never know how much time it will take to get data from server\r\nso this process is expected to take time and so we busy our event loop thus hanging our page, that&#39;s where Web API come into role it take this function from event loop and deals with server making event loop free so that we can execute next function from queue.The next function in queue is utiliseData() which goes in loop but because of no data available it goes waste and execution of next function continues till end of the queue.(This is called Async calling i.e we can do something else till we get data)\r\n\r\nLet suppose our serverRequest() function had a return statement in a code, when we get back data from server Web API will push it in queue at the end of queue.\r\nAs it get pushed at end in queue we cannot utilise its data as there is no function left in our queue to utilise this data.**Thus it is not possible to return something from Async Call.**\r\n\r\nThus Solution to this is *callback* or *promise*.\r\n\r\n*A Image from one of the answers here, Correctly explains callback use...*\r\nWe give our function(function utilising data returned from server) to function calling server.\r\n\r\n[![CallBack][1]][1]\r\n\r\n\r\n     function doAjax(callbackFunc, method, url) {\r\n      var xmlHttpReq = new XMLHttpRequest();\r\n      xmlHttpReq.open(method, url);\r\n      xmlHttpReq.onreadystatechange = function() {\r\n        \r\n          if (xmlHttpReq.readyState == 4 &amp;&amp; xmlHttpReq.status == 200) {\r\n            callbackFunc(xmlHttpReq.responseText);\r\n          }\r\n         \r\n          \r\n      }\r\n      xmlHttpReq.send(null);\r\n      \r\n    }\r\nIn my Code it is called as\r\n\r\n    function loadMyJson(categoryValue){\r\n      if(categoryValue===&quot;veg&quot;)\r\n      doAjax(print,&quot;GET&quot;,&quot;http://localhost:3004/vegetables&quot;);\r\n      else if(categoryValue===&quot;fruits&quot;)\r\n      doAjax(print,&quot;GET&quot;,&quot;http://localhost:3004/fruits&quot;);\r\n      else \r\n      console.log(&quot;Data not found&quot;);\r\n    }\r\n\r\n[Javscript.info callback][2]\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/UCJgN.png\r\n  [2]: https://javascript.info/callbacks"},{"score":42,"body_markdown":"ECMAScript 6 has &#39;generators&#39; which allow you to easily program in an asynchronous style.\r\n\r\n    function* myGenerator() {\r\n        const callback = yield;\r\n        let [response] = yield $.ajax(&quot;https://stackoverflow.com&quot;, {complete: callback});\r\n        console.log(&quot;response is:&quot;, response);\r\n\r\n        // examples of other things you can do\r\n        yield setTimeout(callback, 1000);\r\n        console.log(&quot;it delayed for 1000ms&quot;);\r\n        while (response.statusText === &quot;error&quot;) {\r\n            [response] = yield* anotherGenerator();\r\n        }\r\n    }\r\n\r\nTo run the above code you do this:\r\n\r\n    const gen = myGenerator(); // Create generator\r\n    gen.next(); // Start it\r\n    gen.next((...args) =&gt; gen.next([...args])); // Set its callback function\r\n\r\nIf you need to target browsers that don&#39;t support ES6 you can run the code through Babel or closure-compiler to generate ECMAScript 5.\r\n\r\nThe callback `...args` are wrapped in an array and destructured when you read them so that the pattern can cope with callbacks that have multiple arguments. For example with [node fs](https://nodejs.org/api/fs.html):\r\n\r\n    const [err, data] = yield fs.readFile(filePath, &quot;utf-8&quot;, callback);\r\n"},{"score":20,"body_markdown":"Rather than throwing code at you, there are 2 concepts that are key to understanding how JS handles callbacks and asynchronicity. (is that even a word?) \r\n\r\n**[The Event Loop and Concurrency Model][1]**\r\n---------------------------------------------\r\n\r\n \r\n\r\nThere are three things you need to be aware of; **The queue; [the event loop][2] and the stack**\r\n\r\nIn broad, simplistic terms, the event loop is like the project manager, it is constantly listening for any functions that want to run and communicates between the queue and the stack. \r\n\r\n    while (queue.waitForMessage()) {\r\n       queue.processNextMessage();\r\n    }\r\n\r\nOnce it receives a message to run something it adds it to the queue. The queue is the list of things that are waiting to execute (like your AJAX request). imagine it like this:\r\n\r\n     1. call foo.com/api/bar using foobarFunc\r\n     2. Go perform an infinite loop\r\n     ... and so on\r\n\r\n\r\nWhen one of these messages is going to execute it pops the message from the queue and creates a stack, the stack is everything JS needs to execute to perform the instruction in the message. So in our example it&#39;s being told to call `foobarFunc`\r\n\r\n    function foobarFunc (var) {\r\n      console.log(anotherFunction(var));\r\n    }\r\n\r\nSo anything that foobarFunc needs to execute (in our case `anotherFunction`) will get pushed onto the stack. executed, and then forgotten about - the event loop will then move onto the next thing in the queue (or listen for messages)\r\n\r\n**The key thing here is the order of execution. That is** \r\n\r\n**WHEN is something going to run**\r\n--------------------------------\r\n\r\nWhen you make a call using AJAX to an external party or run any asynchronous code (a setTimeout for example), Javascript is dependant upon a response before it can proceed.\r\n\r\nThe big question is when will it get the response? The answer is we don&#39;t know - so the event loop is waiting for that message to say &quot;hey run me&quot;. If JS just waited around for that message synchronously your app would freeze and it will suck. So JS carries on executing the next item in the queue whilst waiting for the message to get added back to the queue.\r\n\r\nThat&#39;s why with asynchronous functionality we use things called **callbacks**. It&#39;s kinda like a [promise][3] quite literally. As in I *promise to return something at some point* jQuery uses specific callbacks called `deffered.done` `deffered.fail` and `deffered.always` (amongst others). You can see them all [here][4]\r\n\r\nSo what you need to do is pass a function that is promised to execute at some point with data that is passed to it.\r\n\r\nBecause a callback is not executed immediately but at a later time it&#39;s important to pass the reference to the function not it executed. so\r\n\r\n    function foo(bla) {\r\n      console.log(bla)\r\n    }\r\n\r\nso most of the time (but not always) you&#39;ll pass `foo` not `foo()`\r\n\r\nHopefully that will make some sense. When you encounter things like this that seem confusing - i highly recommend reading the documentation fully to at least get an understanding of it. It will make you a much better developer.\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n  [4]: https://api.jquery.com/category/deferred-object/"},{"score":12,"body_markdown":"Here is an example that works:\r\n\r\n\r\n\r\n    const validateName = async userName =&gt; {\r\n      const url = &quot;abc/xyz&quot;;\r\n      try {\r\n        const response = await axios.get(url);\r\n        return response.data\r\n      } catch (err) {\r\n        return false;\r\n      }\r\n    };\r\n    \r\n    validateName(&quot;user&quot;)\r\n     .then(data =&gt; console.log(data))\r\n     .catch(reason =&gt; console.log(reason.message))"},{"score":-3,"body_markdown":"Simple code example to convert XHR on Node to async-await\r\n\r\n    var XMLHttpRequest = require(&quot;xmlhttprequest&quot;).XMLHttpRequest;\r\n    var xhttp = new XMLHttpRequest();\r\n    \r\n    function xhrWrapWithPromise() {\r\n      return new Promise((resolve, reject) =&gt; {\r\n        xhttp.onreadystatechange = function() {\r\n          if (this.readyState == 4) {\r\n            if (this.status == 200) {\r\n              resolve(this.responseText);\r\n            } else {\r\n              reject(new Error(&quot;Couldn&#39;t feth data finally&quot;));\r\n            }\r\n          }\r\n        };\r\n        xhttp.open(&quot;GET&quot;, &quot;https://www.w3schools.com/xml/xmlhttp_info.txt&quot;, true);\r\n        xhttp.send();\r\n      });\r\n    }\r\n    \r\n    //We need to wrap await in Async function so and anonymous IIFE here\r\n    (async _ =&gt; {\r\n      try {\r\n        let result = await xhrWrapWithPromise();\r\n        console.log(result);\r\n      } catch (error) {\r\n        console.log(error);\r\n      }\r\n    })();"},{"score":30,"body_markdown":"# Using Promise #\r\n\r\nThe most perfect answer to this question is using `Promise`.\r\n\r\n    function ajax(method, url, params) {\r\n      return new Promise(function(resolve, reject) {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.onload = function() {\r\n          resolve(this.responseText);\r\n        };\r\n        xhr.onerror = reject;\r\n        xhr.open(method, url);\r\n        xhr.send(params);\r\n      });\r\n    }\r\n\r\n## Usage ##\r\n\r\n    ajax(&quot;GET&quot;, &quot;/test&quot;, &quot;acrive=1&quot;).then(function(result) {\r\n        // Code depending on result\r\n    })\r\n    .catch(function() {\r\n        // An error occurred\r\n    });\r\n\r\n\r\n----------\r\n\r\n\r\n# But wait...!\r\nThere is a problem with using promises!\r\n## Why should we use our own custom Promise? ##\r\nI was using this solution for a while until I figured out there is an error in old browsers:\r\n\r\n    Uncaught ReferenceError: Promise is not defined\r\nSo i decided to implement my own Promise class for **ES3 to below** js compilers if its not defined. Just add this code before your main code and then safely use Promise!\r\n\r\n    if(typeof Promise === &quot;undefined&quot;){\r\n        function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) { \r\n                throw new TypeError(&quot;Cannot call a class as a function&quot;); \r\n            }\r\n        }\r\n        var Promise = function () {\r\n            function Promise(main) {\r\n                var _this = this;\r\n                _classCallCheck(this, Promise);\r\n                this.value = undefined;\r\n                this.callbacks = [];\r\n                var resolve = function resolve(resolveValue) {\r\n                    _this.value = resolveValue;\r\n                    _this.triggerCallbacks();\r\n                };\r\n                var reject = function reject(rejectValue) {\r\n                    _this.value = rejectValue;\r\n                    _this.triggerCallbacks();\r\n                };\r\n                main(resolve, reject);\r\n            }\r\n            Promise.prototype.then = function then(cb) {\r\n                var _this2 = this;\r\n                var next = new Promise(function (resolve) {\r\n                    _this2.callbacks.push(function (x) {\r\n                        return resolve(cb(x));\r\n                    });\r\n                });\r\n                return next;\r\n            };\r\n            Promise.prototype.catch = function catch_(cb) {\r\n                var _this2 = this;\r\n                var next = new Promise(function (reject) {\r\n                    _this2.callbacks.push(function (x) {\r\n                        return reject(cb(x));\r\n                    });\r\n                });\r\n                return next;\r\n            };\r\n            Promise.prototype.triggerCallbacks = function triggerCallbacks() {\r\n                var _this3 = this;\r\n                this.callbacks.forEach(function (cb) {\r\n                    cb(_this3.value);\r\n                });\r\n            };\r\n            return Promise;\r\n        }();\r\n    }"},{"score":2,"body_markdown":"use of `async/await` with a transpilers like Babel to get it working in older browsers. Youll also have to install this Babel preset and polyfill from npm: npm i -D babel-preset-env babel-polyfill.\r\n\r\n    function getData(ajaxurl) { \r\n      return $.ajax({\r\n        url: ajaxurl,\r\n        type: &#39;GET&#39;,\r\n      });\r\n    };\r\n    \r\n    async test() {\r\n      try {\r\n        const res = await getData(&#39;https://api.icndb.com/jokes/random&#39;)\r\n        console.log(res)\r\n      } catch(err) {\r\n        console.log(err);\r\n      }\r\n    }\r\n\r\n    test();\r\n\r\nor the `.then` callback is just another way to write the same logic.\r\n\r\n\r\n    getData(ajaxurl).then(function(res) {\r\n        console.log(res)\r\n    }\r\n\r\n"},{"score":16,"body_markdown":"# Await\r\n\r\nRequest works in ansynchronous way so you can&#39;t read data in synchronous way as typical code. However using `async/await` you can create async code which looks close/similar to synch code. Code which process request data needs to be wrapped by async function (`load` in below snippet) and inside it you need to add `await` keywort before `foo()` (which also use `async/await`).\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    async function foo() {\r\n      var url= &#39;https://jsonplaceholder.typicode.com/todos/1&#39;;\r\n      var result= await (await fetch(url)).text(); // or .json()\r\n      return result;\r\n    }\r\n\r\n    async function load() {\r\n      var result = await foo();\r\n      console.log(result);\r\n    }\r\n\r\n    load();\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nRemember that `async` function allways wrap (in implicit way) its result into promise (so it return promise)."},{"score":7,"body_markdown":"I think no matter what method or mechanism used, or whatever the framework is (Angular/React) that hides it from you, the following principle holds:\r\n\r\n1. In the flow of the program (think code or even the lowest level: machine code), the data may not arrive back 2 seconds later, 3 seconds later, or may not arrive at all, so there is no usual `return` to use in order to return the data.\r\n\r\n2. It is the classic &quot;observer pattern&quot;. (It can be in the form of a &quot;callback&quot;.) It is: &quot;hey, I am interested in knowing a successful arrival of data; would you let me know when it does.&quot; So you register an observer to be notified (or a function to be called to notify about the successful arrival of the data.) You also usually register an observer for the failure of arrival of such data.\r\n\r\n3. When it is successful arrival of data, or a failure of the return of such data, the registered observers (or callbacks) are notified together with the data (or called with the data). If the observer is registered in the form of a callback function `foo`, then `foo(data)` will be called. If the observer is registered in the form of an object `foo`, then depending on the interface, it could be that `foo.notify(data)` is called.\r\n\r\n\r\n"},{"score":26,"body_markdown":"After reading all the responses here and with my experiences, I would like to resume the detail of\r\n `callback, promise and async/await` for the asynchronous programming in JavaScript.\r\n\r\n**1) Callback :** The fundamental reason for a callback is to run code in response of an event (see the example below). We use callback in JavaScript every time.\r\n\r\n    const body = document.getElementsByTagName(&#39;body&#39;)[0];\r\n    function callback() {\r\n      console.log(&#39;Hello&#39;);\r\n    }\r\n    body.addEventListener(&#39;click&#39;, callback);\r\n\r\nBut if you must use many nested callbacks in the example below, it will be fairy terrible for the code refactoring.\r\n\r\n    asyncCallOne(function callback1() {\r\n      asyncCallTwo(function callback2() {\r\n        asyncCallThree(function callback3() {\r\n            ...\r\n        })\r\n      })\r\n    })\r\n\r\n**2) Promise :** a syntax ES6 - Promise resolves the callback hell issue !\r\n\r\n    const myFirstPromise = new Promise((resolve, reject) =&gt; {\r\n      // We call resolve(...) when what we were doing asynchronously was successful, and reject(...) when it failed.\r\n      // In this example, we use setTimeout(...) to simulate async code. \r\n      // In reality, you will probably be using something like XHR request or an HTML5 API.\r\n      setTimeout(() =&gt; {\r\n        resolve(&quot;Success!&quot;)  // Yay! Everything went well!\r\n      }, 250)\r\n    }) \r\n    \r\n    myFirstPromise\r\n      .then((res) =&gt; {\r\n        return res.json();\r\n      })\r\n      .then((data) =&gt; {\r\n        console.log(data);\r\n      })\r\n      .catch((e) =&gt; {\r\n        console.log(e);\r\n      });\r\n\r\nmyFirstPromise is a Promise instance that represents the process of async codes. The resolve function signals that the Promise instance has finished. Afterwards, we can call .then() (a chain of .then as you want) and .catch() on the promise instance:\r\n\r\n    then  Runs a callback you pass to it when the promise has fulfilled.\r\n    catch  Runs a callback you pass to it when something went wrong.\r\n\r\n**3) Async/Await :** a new syntax ES6 - Await is basically sugar syntax of Promise !\r\n\r\nAsync function provide us with a clean and concise syntax that enables us to write less code to accomplish the same outcome we would get with promises. **Async/Await looks similar to synchronous code**, and synchronous code is much easier to read and write. To catch errors with Async/Await, we can use the block `try...catch`. In here, you don&#39;t need to write a chain of .then() of Promise syntax.\r\n\r\n    const getExchangeRate = async () =&gt; {\r\n      try {\r\n        const res = await fetch(&#39;https://getExchangeRateData&#39;);\r\n        const data = await res.json();\r\n        console.log(data);\r\n      } catch (err) {\r\n        console.error(err);\r\n      }\r\n    }\r\n\r\n    getExchangeRate();\r\n\r\n\r\n&gt; Conclusion : These are totally the three syntaxs for asynchronous\r\n&gt; programming in JavaScript that you shoud well understand. **So if possible, I\r\n&gt; recommend that you should use &quot;promise&quot; or &quot;async/await&quot; for\r\n&gt; refactoring your asynchronous codes (mostly for XHR requests)** ! \r\n"},{"score":9,"body_markdown":"There is no way by which you can return the result of an ajax response from a function, the reason why this is not possible is because Ajax call ($.get() or $.post()) is an async call and calling the function that encapsulates the Ajax call returns even before the response is rendered.\r\n\r\nIn such scenarios, the only option is to return a promise object, which will resolve when the response arrives.\r\n\r\nThere are 2 ways by which the above issue can be resolved, in both cases it makes use of promise.\r\n\r\nBoth the code snippets provided are working including the josn url and can be directly copied to jsfiddle and tested.\r\n\r\nOption #1: Return the Ajax call directly from the foo method, in the latest version of Jquery ajax call returns a promise object, which can be resolved using a .then function. the input parameter to the .then function is the call back to the resolve function.\r\n\r\n        //decalre function foo\r\n       function foo(url)\r\n       {\r\n         return $.get(url);\r\n       }\r\n\r\n       //invoke foo function, which returns a promise object\r\n       //the then function accepts the call back to the resolve function\r\n       foo(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;)\r\n       .then(function(response)\r\n       {\r\n\t\tconsole.log(response);\r\n       })\r\n\r\nOption #2 - declare a promise object inside the function and encapsulate the Ajax call within that promise function and return the promise object.\r\n\r\n       function foo1() {\r\n    \r\n       var promise = new Promise(function(resolve, reject)\r\n       {\r\n    \r\n    \t $.ajax({\r\n        url: &#39;https://jsonplaceholder.typicode.com/todos/1&#39;,\r\n        success: function(response) {\r\n            console.log(response);\r\n            \r\n            resolve(response);\r\n            // return response; // &lt;- I tried that one as well\r\n          }\r\n        });\r\n      \r\n       });\r\n\r\n   \r\n\r\n       return promise;\r\n       }\r\n\r\n       foo1()\r\n       .then(function(response)\r\n       {\r\n         console.log(&#39;Promise Resolved&#39;);\r\n         console.log(response);\r\n       })\r\n"},{"score":6,"body_markdown":"Originally, callback were used for asynchronous operations (e.g. in the [XMLHttpRequest API][1]). Now promise-based APIs like the browser&#39;s [Fetch API][2] have become the default solution and the nicer [`async/await`][3] syntax is supported by all modern browsers and on Node.Js (server side).\r\n\r\nA common scenario - fetching JSON data from the server - can look like this:\r\n\r\n```\r\nasync function fetchResource(url) {\r\n  const res = await fetch(url);\r\n  if (!res.ok) {\r\n    throw new Error(res.statusText);\r\n  }\r\n  return res.json();\r\n}\r\n```\r\n\r\nTo use it in another function:\r\n\r\n```\r\nasync function doSomething() {\r\n  try {\r\n    const data = await fetchResource(&quot;https://example.test/resource/1&quot;);\r\n    // ...\r\n  } catch (e) {\r\n    // handle error\r\n    ...\r\n  }\r\n}\r\n```\r\n\r\nIf you design a modern API, it is strongly recommended to prefer promise-based style over callbacks. If you inherited an API that relies on callbacks, it is possible to wrap it as a promise:\r\n\r\n```\r\nfunction sleep(timeout) {\r\n  return new Promise((resolve) =&gt; {\r\n    setTimeout(() =&gt; {\r\n      resolve();\r\n    }, timeout);\r\n  });\r\n}\r\n\r\nasync function fetchAfterTwoSeconds(url) {\r\n  await sleep(2000);\r\n  return fetchResource(url);\r\n}\r\n```\r\n\r\nIn Node.Js, which historically relied exclusively on callbacks, that technique is so common that they added a helper function called [`util.promisify`][4].\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\r\n  [4]: https://nodejs.org/api/util.html#util_util_promisify_original"},{"score":-4,"body_markdown":"Since &#39;await&#39; always returns a Promise, simply do an extra &#39;await&#39; (inside an async function) to extract the value:\r\n\r\n    test(); // This alerts &quot;hello&quot;\r\n\r\n    // This is the outer function that wants to get the string result of inner()\r\n    async function test() {\r\n        var str=await await inner();\r\n        alert(str);\r\n        } // test\r\n\r\n    // This ia an inner function that can do arbitrary async operations\r\n    async function inner() {\r\n        return Promise.resolve(&#39;hello&#39;);\r\n        }\r\n"},{"score":2,"body_markdown":"## async: false ##\r\n\r\nI solved by set sync false and restructure my ajax call : \r\n\r\nI set global function called `sendRequest(type, url, data)` with three parameters to be called every time everywhere \r\n\r\n    function sendRequest(type, url, data) {\r\n        let returnValue = null;\r\n        $.ajax({\r\n            url: url,\r\n            type: type,\r\n            async: false,\r\n            data: data,\r\n            dataType: &#39;json&#39;,\r\n            success: function (resp) {\r\n                returnValue = resp;\r\n            }\r\n        });\r\n        return returnValue;\r\n    } \r\n\r\nNow call function \r\n\r\n    let password = $(&quot;#password&quot;).val();\r\n            let email = $(&quot;#email&quot;).val();\r\n            let data = {\r\n                email: email,\r\n                password: password,\r\n            };\r\n            let  resp =  sendRequest(&#39;POST&#39;, &#39;http://localhost/signin&#39;)}}&quot;, data);\r\n            console.log(resp);\r\n\r\n\r\n&gt; Important **Note** in code is :  `async: false`"},{"score":1,"body_markdown":"Have a look at this example:\r\n\r\n    var app = angular.module(&#39;plunker&#39;, []);\r\n    \r\n    app.controller(&#39;MainCtrl&#39;, function($scope,$http) {\r\n    \r\n        var getJoke = function(){\r\n            return $http.get(&#39;http://api.icndb.com/jokes/random&#39;).then(function(res){\r\n                return res.data.value;  \r\n            });\r\n        }\r\n    \r\n        getJoke().then(function(res) {\r\n            console.log(res.joke);\r\n        });\r\n    });\r\n\r\nAs you can see getJoke is returning a resolved promise (it is resolved when returning res.data.value). So you wait until the $http.get request is completed and then console.log(res.joke) is executed (as a normal asynchronous flow).\r\n\r\nThis is the plnkr:\r\n\r\n    http://embed.plnkr.co/XlNR7HpCaIhJxskMJfSg/\r\n    \r\n    ES6 way (async - await)\r\n    \r\n    (function(){\r\n      async function getJoke(){\r\n        let response = await fetch(&#39;http://api.icndb.com/jokes/random&#39;);\r\n        let data = await response.json();\r\n        return data.value;\r\n      }\r\n    \r\n      getJoke().then((joke) =&gt; {\r\n        console.log(joke);\r\n      });\r\n    })();"}],"score":5750}