{"body":"I have an object `x`. I&#39;d like to copy it as object `y`, such that changes to `y` do not modify `x`. I realized that copying objects derived from built-in JavaScript objects will result in extra, unwanted properties. This isn&#39;t a problem, since I&#39;m copying one of my own literal-constructed objects.\r\n\r\nHow do I correctly clone a JavaScript object?\r\n","title":"How do I correctly clone a JavaScript object?","answers":[{"score":24,"body_markdown":"From this article: &lt;a href=&quot;https://greywyvern.com/?post=363&quot;&gt;How to copy arrays and objects in Javascript&lt;/a&gt; by Brian Huisman:\r\n\r\n    Object.prototype.clone = function() {\r\n      var newObj = (this instanceof Array) ? [] : {};\r\n      for (var i in this) {\r\n        if (i == &#39;clone&#39;) continue;\r\n        if (this[i] &amp;&amp; typeof this[i] == &quot;object&quot;) {\r\n          newObj[i] = this[i].clone();\r\n        } else newObj[i] = this[i]\r\n      } return newObj;\r\n    };"},{"score":23,"body_markdown":"Here is a function you can use. \r\n\r\n    function clone(obj) {\r\n        if(obj == null || typeof(obj) != &#39;object&#39;)\r\n            return obj;    \r\n        var temp = new obj.constructor(); \r\n        for(var key in obj)\r\n            temp[key] = clone(obj[key]);    \r\n        return temp;\r\n    }"},{"score":1,"body_markdown":"If there are no circular dependencies in your object, I suggest using one of the other answers or [jQuery&#39;s copy methods][1], as they all seem quite effective.\r\n\r\nIf there are circular dependencies (i.e., two sub-objects link to each other), you are kind of screwed as there is (from a theoretical perspective) [no way to solve this issue elegantly][2].\r\n\r\n\r\n  [1]: https://stackoverflow.com/questions/122102/what-is-the-most-efficent-way-to-clone-a-javascript-object/122704#122704\r\n  [2]: https://stackoverflow.com/questions/597588/how-do-you-clone-an-array-of-objects-in-javascript/597726#597726"},{"score":0,"body_markdown":"From the [Apple JavaScript Coding Guidelines][1]:\r\n\r\n    // Create an inner object with a variable x whose default\r\n    // value is 3.\r\n    function innerObj()\r\n    {\r\n            this.x = 3;\r\n    }\r\n    innerObj.prototype.clone = function() {\r\n        var temp = new innerObj();\r\n        for (myvar in this) {\r\n            // this object does not contain any objects, so\r\n            // use the lightweight copy code.\r\n            temp[myvar] = this[myvar];\r\n        }\r\n        return temp;\r\n    }\r\n     \r\n    // Create an outer object with a variable y whose default\r\n    // value is 77.\r\n    function outerObj()\r\n    {\r\n            // The outer object contains an inner object.  Allocate it here.\r\n            this.inner = new innerObj();\r\n            this.y = 77;\r\n    }\r\n    outerObj.prototype.clone = function() {\r\n        var temp = new outerObj();\r\n        for (myvar in this) {\r\n            if (this[myvar].clone) {\r\n                // This variable contains an object with a\r\n                // clone operator.  Call it to create a copy.\r\n                temp[myvar] = this[myvar].clone();\r\n            } else {\r\n                // This variable contains a scalar value,\r\n                // a string value, or an object with no\r\n                // clone function.  Assign it directly.\r\n                temp[myvar] = this[myvar];\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n     \r\n    // Allocate an outer object and assign non-default values to variables in\r\n    // both the outer and inner objects.\r\n    outer = new outerObj;\r\n    outer.inner.x = 4;\r\n    outer.y = 16;\r\n     \r\n    // Clone the outer object (which, in turn, clones the inner object).\r\n    newouter = outer.clone();\r\n     \r\n    // Verify that both values were copied.\r\n    alert(&#39;inner x is &#39;+newouter.inner.x); // prints 4\r\n    alert(&#39;y is &#39;+newouter.y); // prints 16\r\n\r\nSteve\r\n\r\n  [1]: http://developer.apple.com/DOCUMENTATION/ScriptingAutomation/Conceptual/JSCodingGuide/OOJavaScript/OOJavaScript.html#//apple_ref/doc/uid/TP40006539-SW3"},{"score":1607,"body_markdown":"To do this for any object in JavaScript will not be simple or straightforward. You will run into the problem of erroneously picking up attributes from the object&#39;s prototype that should be left in the prototype and not copied to the new instance. If, for instance, you are adding a `clone` method to `Object.prototype`, as some answers depict, you will need to explicitly skip that attribute. But what if there are other additional methods added to `Object.prototype`, or other intermediate prototypes, that you don&#39;t know about? In that case, you will copy attributes you shouldn&#39;t, so you need to detect unforeseen, non-local attributes with the [`hasOwnProperty`][1] method.\r\n\r\nIn addition to non-enumerable attributes, you&#39;ll encounter a tougher problem when you try to copy objects that have hidden properties. For example, `prototype` is a hidden property of a function. Also, an object&#39;s prototype is referenced with the attribute `__proto__`, which is also hidden, and will not be copied by a for/in loop iterating over the source object&#39;s attributes. I think `__proto__` might be specific to Firefox&#39;s JavaScript interpreter and it may be something different in other browsers, but you get the picture. Not everything is enumerable. You can copy a hidden attribute if you know its name, but I don&#39;t know of any way to discover it automatically.\r\n\r\nYet another snag in the quest for an elegant solution is the problem of setting up the prototype inheritance correctly. If your source object&#39;s prototype is `Object`, then simply creating a new general object with `{}` will work, but if the source&#39;s prototype is some descendant of `Object`, then you are going to be missing the additional members from that prototype which you skipped using the `hasOwnProperty` filter, or which were in the prototype, but weren&#39;t enumerable in the first place. One solution might be to call the source object&#39;s `constructor` property to get the initial copy object and then copy over the attributes, but then you still will not get non-enumerable attributes. For example, a [`Date`][2] object stores its data as a hidden member:\r\n\r\n    function clone(obj) {\r\n        if (null == obj || &quot;object&quot; != typeof obj) return obj;\r\n        var copy = obj.constructor();\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];\r\n        }\r\n        return copy;\r\n    }\r\n\r\n    var d1 = new Date();\r\n\r\n    /* Executes function after 5 seconds. */\r\n    setTimeout(function(){\r\n        var d2 = clone(d1);\r\n        alert(&quot;d1 = &quot; + d1.toString() + &quot;\\nd2 = &quot; + d2.toString());\r\n    }, 5000);\r\n\r\n\r\nThe date string for `d1` will be 5 seconds behind that of `d2`. A way to make one `Date` the same as another is by calling the `setTime` method, but that is specific to the `Date` class. I don&#39;t think there is a bullet-proof general solution to this problem, though I would be happy to be wrong!\r\n\r\nWhen I had to implement general deep copying I ended up compromising by assuming that I would only need to copy a plain `Object`, `Array`, `Date`, `String`, `Number`, or `Boolean`. The last 3 types are immutable, so I could perform a shallow copy and not worry about it changing. I further assumed that any elements contained in `Object` or `Array` would also be one of the 6 simple types in that list. This can be accomplished with code like the following:\r\n\r\n    function clone(obj) {\r\n        var copy;\r\n\r\n        // Handle the 3 simple types, and null or undefined\r\n        if (null == obj || &quot;object&quot; != typeof obj) return obj;\r\n\r\n        // Handle Date\r\n        if (obj instanceof Date) {\r\n            copy = new Date();\r\n            copy.setTime(obj.getTime());\r\n            return copy;\r\n        }\r\n\r\n        // Handle Array\r\n        if (obj instanceof Array) {\r\n            copy = [];\r\n            for (var i = 0, len = obj.length; i &lt; len; i++) {\r\n                copy[i] = clone(obj[i]);\r\n            }\r\n            return copy;\r\n        }\r\n\r\n        // Handle Object\r\n        if (obj instanceof Object) {\r\n            copy = {};\r\n            for (var attr in obj) {\r\n                if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);\r\n            }\r\n            return copy;\r\n        }\r\n\r\n        throw new Error(&quot;Unable to copy obj! Its type isn&#39;t supported.&quot;);\r\n    }\r\n\r\n\r\nThe above function will work adequately for the 6 simple types I mentioned, as long as the data in the objects and arrays form a tree structure. That is, there isn&#39;t more than one reference to the same data in the object. For example:\r\n\r\n    // This would be cloneable:\r\n    var tree = {\r\n        &quot;left&quot;  : { &quot;left&quot; : null, &quot;right&quot; : null, &quot;data&quot; : 3 },\r\n        &quot;right&quot; : null,\r\n        &quot;data&quot;  : 8\r\n    };\r\n    \r\n    // This would kind-of work, but you would get 2 copies of the \r\n    // inner node instead of 2 references to the same copy\r\n    var directedAcylicGraph = {\r\n        &quot;left&quot;  : { &quot;left&quot; : null, &quot;right&quot; : null, &quot;data&quot; : 3 },\r\n        &quot;data&quot;  : 8\r\n    };\r\n    directedAcyclicGraph[&quot;right&quot;] = directedAcyclicGraph[&quot;left&quot;];\r\n    \r\n    // Cloning this would cause a stack overflow due to infinite recursion:\r\n    var cyclicGraph = {\r\n        &quot;left&quot;  : { &quot;left&quot; : null, &quot;right&quot; : null, &quot;data&quot; : 3 },\r\n        &quot;data&quot;  : 8\r\n    };\r\n    cyclicGraph[&quot;right&quot;] = cyclicGraph;\r\n\r\n\r\nIt will not be able to handle any JavaScript object, but it may be sufficient for many purposes as long as you don&#39;t assume that it will just work for anything you throw at it.\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/hasOwnProperty &quot;Mozilla JavaScript Reference: Object.hasOwnProperty&quot;\r\n  [2]: https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date &quot;Mozilla JavaScript Reference: Date&quot;"},{"score":42,"body_markdown":"One particularly inelegant solution is to use JSON encoding to make deep copies of objects that do not have member methods. The methodology is to JSON encode your target object, then by decoding it, you get the copy you are looking for.  You can decode as many times as you want to make as many copies as you need.\r\n\r\nOf course, functions do not belong in JSON, so this only works for objects without member methods.\r\n\r\nThis methodology was perfect for my use case, since I&#39;m storing JSON blobs in a key-value store, and when they are exposed as objects in a JavaScript API, each object actually contains a copy of the original state of the object so we can calculate the delta after the caller has mutated the exposed object.\r\n\r\n    var object1 = {key:&quot;value&quot;};\r\n    var object2 = object1;\r\n    \r\n    object2 = JSON.stringify(object1);\r\n    object2 = JSON.parse(object2);\r\n    \r\n    object2.key = &quot;a change&quot;;\r\n    console.log(object1);// returns value\r\n\r\n"},{"score":791,"body_markdown":"With jQuery, you can **shallow copy** with [extend][1]:\r\n\r\n    var copiedObject = jQuery.extend({}, originalObject)\r\n\r\nsubsequent changes to the `copiedObject` will not affect the `originalObject`, and vice versa.\r\n\r\nOr to make a **deep copy**:\r\n\r\n    var copiedObject = jQuery.extend(true, {}, originalObject)\r\n\r\n\r\n  [1]: http://api.jquery.com/jQuery.extend"},{"score":24,"body_markdown":"A.Levy&#39;s answer is almost complete, here is my little contribution: **there is a way how to handle recursive references**, see this line\r\n\r\n`if(this[attr]==this) copy[attr] = copy;`\r\n\r\nIf the object is XML DOM element, we must use **cloneNode** instead\r\n\r\n`if(this.cloneNode) return this.cloneNode(true);`\r\n\r\n\r\nInspired by A.Levy&#39;s exhaustive study and Calvin&#39;s prototyping approach, I offer this solution:\r\n\r\n\r\n    Object.prototype.clone = function() {\r\n      if(this.cloneNode) return this.cloneNode(true);\r\n      var copy = this instanceof Array ? [] : {};\r\n      for(var attr in this) {\r\n        if(typeof this[attr] == &quot;function&quot; || this[attr]==null || !this[attr].clone)\r\n          copy[attr] = this[attr];\r\n        else if(this[attr]==this) copy[attr] = copy;\r\n        else copy[attr] = this[attr].clone();\r\n      }\r\n      return copy;\r\n    }\r\n    \r\n    Date.prototype.clone = function() {\r\n      var copy = new Date();\r\n      copy.setTime(this.getTime());\r\n      return copy;\r\n    }\r\n    \r\n    Number.prototype.clone = \r\n    Boolean.prototype.clone =\r\n    String.prototype.clone = function() {\r\n      return this;\r\n    }\r\n\r\nSee also Andy Burke&#39;s note in the answers."},{"score":136,"body_markdown":"There are many answers, but none that mentions [Object.create](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create) from ECMAScript 5, which admittedly does not give you an exact copy, but sets the source as the prototype of the new object.\r\n\r\nThus, this is not an exact answer to the question, but it is a one-line solution and thus elegant. And it works best for 2 cases:\r\n\r\n 1. Where such inheritance is useful (duh!)\r\n 2. Where the source object won&#39;t be modified, thus making the relation between the 2 objects a non issue.\r\n\r\nExample:\r\n\r\n    var foo = { a : 1 };\r\n    var bar = Object.create(foo);\r\n    foo.a; // 1\r\n    bar.a; // 1\r\n    foo.a = 2;\r\n    bar.a; // 2 - prototype changed\r\n    bar.a = 3;\r\n    foo.a; // Still 2, since setting bar.a makes it an &quot;own&quot; property\r\n\r\nWhy do I consider this solution to be superior? It&#39;s native, thus no looping, no recursion. However, older browsers will need a polyfill."},{"score":5,"body_markdown":"Jan Turo≈à&#39;s answer above is very close, and may be the best to use in a browser due to compatibility issues, but it will potentially cause some strange enumeration issues.  For instance, executing:\r\n\r\n    for ( var i in someArray ) { ... }\r\n\r\nWill assign the clone() method to i after iterating through the elements of the array.  Here&#39;s an adaptation that avoids the enumeration and works with node.js:\r\n\r\n    Object.defineProperty( Object.prototype, &quot;clone&quot;, {\r\n        value: function() {\r\n            if ( this.cloneNode )\r\n            {\r\n                return this.cloneNode( true );\r\n            }\r\n        \r\n            var copy = this instanceof Array ? [] : {};\r\n            for( var attr in this )\r\n            {\r\n                if ( typeof this[ attr ] == &quot;function&quot; || this[ attr ] == null || !this[ attr ].clone )\r\n                {\r\n                    copy[ attr ] = this[ attr ];\r\n                }\r\n                else if ( this[ attr ] == this )\r\n                {\r\n                    copy[ attr ] = copy;\r\n                }\r\n                else\r\n                {\r\n                    copy[ attr ] = this[ attr ].clone();\r\n                }\r\n            }\r\n            return copy;\r\n        }\r\n    });\r\n\r\n    Object.defineProperty( Date.prototype, &quot;clone&quot;, {\r\n        value: function() {\r\n            var copy = new Date();\r\n            copy.setTime( this.getTime() );\r\n            return copy;\r\n        }\r\n    });\r\n\r\n    Object.defineProperty( Number.prototype, &quot;clone&quot;, { value: function() { return this; } } );\r\n    Object.defineProperty( Boolean.prototype, &quot;clone&quot;, { value: function() { return this; } } );\r\n    Object.defineProperty( String.prototype, &quot;clone&quot;, { value: function() { return this; } } );\r\n\r\nThis avoids making the clone() method enumerable because defineProperty() defaults enumerable to false.\r\n"},{"score":14,"body_markdown":"You can clone an object and remove any reference from the previous one using a single line of code. Simply do:\r\n\r\n    var obj1 = { text: &#39;moo1&#39; };\r\n    var obj2 = Object.create(obj1); // Creates a new clone without references\r\n    \r\n    obj2.text = &#39;moo2&#39;; // Only updates obj2&#39;s text property\r\n    \r\n    console.log(obj1, obj2); // Outputs: obj1: {text:&#39;moo1&#39;}, obj2: {text:&#39;moo2&#39;}\r\n\r\nFor browsers / engines that do not currently support Object.create you can use this polyfill:\r\n\r\n    // Polyfill Object.create if it does not exist\r\n    if (!Object.create) {\r\n    \tObject.create = function (o) {\r\n    \t\tvar F = function () {};\r\n    \t\tF.prototype = o;\r\n    \t\treturn new F();\r\n    \t};\r\n    }"},{"score":6,"body_markdown":"I just wanted to add to all the `Object.create` solutions in this post, that this does not work in the desired way with nodejs. \r\n\r\nIn Firefox the result of\r\n\r\n    var a = {&quot;test&quot;:&quot;test&quot;};\r\n    var b = Object.create(a);\r\n    console.log(b);&#180;\r\n\r\nis \r\n\r\n`{test:&quot;test&quot;}`.\r\n\r\nIn nodejs it is \r\n\r\n    {}\r\n\r\n\r\n"},{"score":1007,"body_markdown":"If you do not use `Date`s, functions, undefined, regExp or Infinity within your object, a very simple one liner is `JSON.parse(JSON.stringify(object))`:\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const a = {\r\n      string: &#39;string&#39;,\r\n      number: 123,\r\n      bool: false,\r\n      nul: null,\r\n      date: new Date(),  // stringified\r\n      undef: undefined,  // lost\r\n      inf: Infinity,  // forced to &#39;null&#39;\r\n    }\r\n    console.log(a);\r\n    console.log(typeof a.date);  // Date object\r\n    const clone = JSON.parse(JSON.stringify(a));\r\n    console.log(clone);\r\n    console.log(typeof clone.date);  // result of .toISOString()\r\n\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThis works for all kind of objects containing objects, arrays, strings, booleans and numbers.\r\n\r\nSee also [this article about the structured clone algorithm of browsers](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm) which is used when posting messages to and from a worker. It also contains a function for deep cloning."},{"score":79,"body_markdown":"If you&#39;re okay with a shallow copy, the underscore.js library has a [clone](http://underscorejs.org/#clone) method.\r\n\r\n    y = _.clone(x);\r\n\r\nor you can extend it like\r\n\r\n    copiedObject = _.extend({},originalObject);"},{"score":8,"body_markdown":"This is an adaptation of A. Levy&#39;s code to also handle the cloning of functions and multiple/cyclic references - what this means is that if two properties in the tree which is cloned are references of the same object, the cloned object tree will have these properties point to one and the same clone of the referenced object. This also solves the case of cyclic dependencies which, if left unhandled, leads to an infinite loop. The complexity of the algorithm is O(n)\r\n\r\n\r\n    function clone(obj){\r\n    \tvar clonedObjectsArray = [];\r\n    \tvar originalObjectsArray = []; //used to remove the unique ids when finished\r\n    \tvar next_objid = 0;\r\n    \t\r\n    \tfunction objectId(obj) {\r\n    \t\tif (obj == null) return null;\r\n    \t\tif (obj.__obj_id == undefined){\r\n    \t\t\tobj.__obj_id = next_objid++;\r\n    \t\t\toriginalObjectsArray[obj.__obj_id] = obj;\r\n    \t\t}\r\n    \t\treturn obj.__obj_id;\r\n    \t}\r\n    \r\n    \tfunction cloneRecursive(obj) {\r\n    \t\tif (null == obj || typeof obj == &quot;string&quot; || typeof obj == &quot;number&quot; || typeof obj == &quot;boolean&quot;) return obj;\r\n    \r\n    \t\t// Handle Date\r\n    \t\tif (obj instanceof Date) {\r\n    \t\t\tvar copy = new Date();\r\n    \t\t\tcopy.setTime(obj.getTime());\r\n    \t\t\treturn copy;\r\n    \t\t}\r\n    \r\n    \t\t// Handle Array\r\n    \t\tif (obj instanceof Array) {\r\n    \t\t\tvar copy = [];\r\n    \t\t\tfor (var i = 0; i &lt; obj.length; ++i) {\r\n    \t\t\t\tcopy[i] = cloneRecursive(obj[i]);\r\n    \t\t\t}\r\n    \t\t\treturn copy;\r\n    \t\t}\r\n    \r\n    \t\t// Handle Object\r\n    \t\tif (obj instanceof Object) {\r\n    \t\t\tif (clonedObjectsArray[objectId(obj)] != undefined)\r\n    \t\t\t\treturn clonedObjectsArray[objectId(obj)];\r\n    \t\t\t\r\n    \t\t\tvar copy;\r\n    \t\t\tif (obj instanceof Function)//Handle Function\r\n    \t\t\t\tcopy = function(){return obj.apply(this, arguments);};\r\n    \t\t\telse\r\n    \t\t\t\tcopy = {};\r\n    \t\t\t\r\n    \t\t\tclonedObjectsArray[objectId(obj)] = copy;\r\n    \t\t\t\r\n    \t\t\tfor (var attr in obj)\r\n    \t\t\t\tif (attr != &quot;__obj_id&quot; &amp;&amp; obj.hasOwnProperty(attr))\r\n    \t\t\t\t\tcopy[attr] = cloneRecursive(obj[attr]);\t\t\t\t\t\r\n    \t\t\t\r\n    \t\t\treturn copy;\r\n    \t\t}\t\t\r\n    \t\t\r\n    \t\t\r\n    \t\tthrow new Error(&quot;Unable to copy obj! Its type isn&#39;t supported.&quot;);\r\n    \t}\r\n    \tvar cloneObj = cloneRecursive(obj);\r\n    \t\r\n    \r\n    \t\r\n    \t//remove the unique ids\r\n    \tfor (var i = 0; i &lt; originalObjectsArray.length; i++)\r\n    \t{\r\n    \t\tdelete originalObjectsArray[i].__obj_id;\r\n    \t};\r\n    \t\r\n    \treturn cloneObj;\r\n    }\r\n\r\nSome quick tests\r\n\r\n    var auxobj = {\r\n    \tprop1 : &quot;prop1 aux val&quot;, \r\n    \tprop2 : [&quot;prop2 item1&quot;, &quot;prop2 item2&quot;]\r\n    \t};\r\n    \r\n    var obj = new Object();\r\n    obj.prop1 = &quot;prop1_value&quot;;\r\n    obj.prop2 = [auxobj, auxobj, &quot;some extra val&quot;, undefined];\r\n    obj.nr = 3465;\r\n    obj.bool = true;\r\n    \r\n    obj.f1 = function (){\r\n    \tthis.prop1 = &quot;prop1 val changed by f1&quot;;\r\n    };\r\n    \r\n    objclone = clone(obj);\r\n    \r\n    //some tests i&#39;ve made\r\n    console.log(&quot;test number, boolean and string cloning: &quot; + (objclone.prop1 == obj.prop1 &amp;&amp; objclone.nr == obj.nr &amp;&amp; objclone.bool == obj.bool));\r\n    \r\n    objclone.f1();\r\n    console.log(&quot;test function cloning 1: &quot; + (objclone.prop1 == &#39;prop1 val changed by f1&#39;));\r\n    objclone.f1.prop = &#39;some prop&#39;;\r\n    console.log(&quot;test function cloning 2: &quot; + (obj.f1.prop == undefined));\r\n    \r\n    objclone.prop2[0].prop1 = &quot;prop1 aux val NEW&quot;;\r\n    console.log(&quot;test multiple references cloning 1: &quot; + (objclone.prop2[1].prop1 == objclone.prop2[0].prop1));\r\n    console.log(&quot;test multiple references cloning 2: &quot; + (objclone.prop2[1].prop1 != obj.prop2[0].prop1));"},{"score":6,"body_markdown":"\r\n\r\n    function clone(src, deep) {\r\n    \r\n        var toString = Object.prototype.toString;\r\n        if(!src &amp;&amp; typeof src != &quot;object&quot;){\r\n            //any non-object ( Boolean, String, Number ), null, undefined, NaN\r\n            return src;\r\n        }\r\n     \r\n        //Honor native/custom clone methods\r\n        if(src.clone &amp;&amp; toString.call(src.clone) == &quot;[object Function]&quot;){\r\n            return src.clone(deep);\r\n        }\r\n     \r\n        //DOM Elements\r\n        if(src.nodeType &amp;&amp; toString.call(src.cloneNode) == &quot;[object Function]&quot;){\r\n            return src.cloneNode(deep);\r\n        }\r\n     \r\n        //Date\r\n        if(toString.call(src) == &quot;[object Date]&quot;){\r\n            return new Date(src.getTime());\r\n        }\r\n     \r\n        //RegExp\r\n        if(toString.call(src) == &quot;[object RegExp]&quot;){\r\n            return new RegExp(src);\r\n        }\r\n     \r\n        //Function\r\n        if(toString.call(src) == &quot;[object Function]&quot;){\r\n            //Wrap in another method to make sure == is not true;\r\n            //Note: Huge performance issue due to closures, comment this :)\r\n            return (function(){\r\n                src.apply(this, arguments);\r\n            });\r\n     \r\n        }\r\n     \r\n        var ret, index;\r\n        //Array\r\n        if(toString.call(src) == &quot;[object Array]&quot;){\r\n            //[].slice(0) would soft clone\r\n            ret = src.slice();\r\n            if(deep){\r\n                index = ret.length;\r\n                while(index--){\r\n                    ret[index] = clone(ret[index], true);\r\n                }\r\n            }\r\n        }\r\n        //Object\r\n        else {\r\n            ret = src.constructor ? new src.constructor() : {};\r\n            for (var prop in src) {\r\n                ret[prop] = deep\r\n                    ? clone(src[prop], true)\r\n                    : src[prop];\r\n            }\r\n        }\r\n     \r\n        return ret;\r\n    };"},{"score":6,"body_markdown":"Since [mindeavor][1] stated that the object to be cloned is a &#39;literal-constructed&#39; object, a solution might be to simply *generate* the object multiple times rather than cloning an instance of the object:\r\n\r\n    function createMyObject()\r\n    {\r\n        var myObject =\r\n        {\r\n            ...\r\n        };\r\n        return myObject;\r\n    }\r\n    \r\n    var myObjectInstance1 = createMyObject();\r\n    var myObjectInstance2 = createMyObject();\r\n\r\n  [1]: https://stackoverflow.com/users/49695/mindeavor"},{"score":18,"body_markdown":"Using Lodash: \r\n\r\n    var y = _.clone(x, true);"},{"score":2,"body_markdown":"In my code I frequently define a `function (_)` to handle copies so that I can pass `by value` to functions. This code creates a deep copy but maintains inheritance. It also keeps track of sub-copies so that self-referential objects can be copied without an infinite loop. Feel free to use it.\r\n\r\nIt might not be the most elegant, but it hasn&#39;t failed me yet.\r\n\r\n    _ = function(oReferance) {\r\n      var aReferances = new Array();\r\n      var getPrototypeOf = function(oObject) {\r\n        if(typeof(Object.getPrototypeOf)!==&quot;undefined&quot;) return Object.getPrototypeOf(oObject);\r\n        var oTest = new Object();\r\n        if(typeof(oObject.__proto__)!==&quot;undefined&quot;&amp;&amp;typeof(oTest.__proto__)!==&quot;undefined&quot;&amp;&amp;oTest.__proto__===Object.prototype) return oObject.__proto__;\r\n        if(typeof(oObject.constructor)!==&quot;undefined&quot;&amp;&amp;typeof(oTest.constructor)!==&quot;undefined&quot;&amp;&amp;oTest.constructor===Object&amp;&amp;typeof(oObject.constructor.prototype)!==&quot;undefined&quot;) return oObject.constructor.prototype;\r\n        return Object.prototype;\r\n      };\r\n      var recursiveCopy = function(oSource) {\r\n        if(typeof(oSource)!==&quot;object&quot;) return oSource;\r\n        if(oSource===null) return null;\r\n        for(var i=0;i&lt;aReferances.length;i++) if(aReferances[i][0]===oSource) return aReferances[i][1];\r\n        var Copy = new Function();\r\n        Copy.prototype = getPrototypeOf(oSource);\r\n        var oCopy = new Copy();\r\n        aReferances.push([oSource,oCopy]);\r\n        for(sPropertyName in oSource) if(oSource.hasOwnProperty(sPropertyName)) oCopy[sPropertyName] = recursiveCopy(oSource[sPropertyName]);\r\n        return oCopy;\r\n      };\r\n      return recursiveCopy(oReferance);\r\n    };\r\n\r\n    // Examples:\r\n    Wigit = function(){};\r\n    Wigit.prototype.bInThePrototype = true;\r\n    A = new Wigit();\r\n    A.nCoolNumber = 7;\r\n    B = _(A);\r\n    B.nCoolNumber = 8; // A.nCoolNumber is still 7\r\n    B.bInThePrototype // true\r\n    B instanceof Wigit // true"},{"score":4,"body_markdown":"Consult http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#safe-passing-of-structured-data for the W3C&#39;s &quot;Safe passing of structured data&quot; algorithm, intended to be implemented by browsers for passing data to eg web workers. However, it has some limitations, in that it does not handle functions. See https://developer.mozilla.org/en-US/docs/DOM/The_structured_clone_algorithm for more information, including an alternative algorithm in JS which gets you part of the way there."},{"score":-2,"body_markdown":"My favorite &amp; elegant JS objects **clone** solution is\r\n\r\n    function CloneObject() {}\r\n    function cloneObject(o) {\r\n       CloneObject.prototype = o;\r\n       return new CloneObject();\r\n    }\r\n\r\nUse `cloneObject(object)` to get a clone of JS object.\r\n\r\nUnlike many **copy** solutions this clone keeps prototype relationship in cloned object."},{"score":0,"body_markdown":"\t//\r\n\t// creates &#39;clone&#39; method on context object\r\n\t//\r\n\t//  var \r\n\t//     clon = Object.clone( anyValue );\r\n\t//\r\n\t!((function (propertyName, definition) {\r\n\t\tthis[propertyName] = definition();\r\n\t}).call(\r\n\t\tObject,\r\n\t\t&quot;clone&quot;,\r\n\t\tfunction () {\r\n\t\t\tfunction isfn(fn) {\r\n\t\t\t\treturn typeof fn === &quot;function&quot;;\r\n\t\t\t}\r\n\r\n\t\t\tfunction isobj(o) {\r\n\t\t\t\treturn o === Object(o);\r\n\t\t\t}\r\n\r\n\t\t\tfunction isarray(o) {\r\n\t\t\t\treturn Object.prototype.toString.call(o) === &quot;[object Array]&quot;;\r\n\t\t\t}\r\n\r\n\t\t\tfunction fnclon(fn) {\r\n\t\t\t\treturn function () {\r\n\t\t\t\t\tfn.apply(this, arguments);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tfunction owns(obj, p) {\r\n\t\t\t\treturn obj.hasOwnProperty(p);\r\n\t\t\t}\r\n\r\n\t\t\tfunction isemptyobj(obj) {\r\n\t\t\t\tfor (var p in obj) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tfunction isObject(o) {\r\n\t\t\t\treturn Object.prototype.toString.call(o) === &quot;[object Object]&quot;;\r\n\t\t\t}\r\n\t\t\treturn function (input) {\r\n\t\t\t\tif (isfn(input)) {\r\n\t\t\t\t\treturn fnclon(input);\r\n\t\t\t\t} else if (isobj(input)) {\r\n\t\t\t\t\tvar cloned = {};\r\n\t\t\t\t\tfor (var p in input) {\r\n\t\t\t\t\t\towns(Object.prototype, p)\r\n\t\t\t\t\t\t|| (\r\n\t\t\t\t\t\t\tisfn(input[p])\r\n\t\t\t\t\t\t\t&amp;&amp; ( cloned[p] = function () { return input[p].apply(input, arguments); } )\r\n\t\t\t\t\t\t\t|| ( cloned[p] = input[p] )\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isarray(input)) {\r\n\t\t\t\t\t\tcloned.length = input.length;\r\n\t\t\t\t\t\t&quot;concat every filter forEach indexOf join lastIndexOf map pop push reduce reduceRight reverse shift slice some sort splice toLocaleString toString unshift&quot;\r\n\t\t\t\t\t\t.split(&quot; &quot;)\r\n\t\t\t\t\t\t.forEach(\r\n\t\t\t\t\t\t  function (methodName) {\r\n\t\t\t\t\t\t\tisfn( Array.prototype[methodName] )\r\n\t\t\t\t\t\t\t&amp;&amp; (\r\n\t\t\t\t\t\t\t\tcloned[methodName] =\r\n\t\t\t\t\t\t\t\tfunction () {\r\n\t\t\t\t\t\t\t\t\treturn Array.prototype[methodName].apply(cloned, arguments);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t  }\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn isemptyobj(cloned)\r\n\t\t\t\t\t\t   ? (\r\n\t\t\t\t\t\t\t  isObject(input)\r\n\t\t\t\t\t\t\t  ? cloned\r\n\t\t\t\t\t\t\t  : input\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t   : cloned;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn input;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t));\r\n    //\r\n"},{"score":4,"body_markdown":"# Structured Cloning\r\n\r\nThe HTML standard includes [**an internal structured cloning/serialization algorithm**][1] that can create deep clones of objects. It is still limited to certain built-in types, but in addition to the few types supported by JSON it also supports Dates, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays, and probably more in the future. It also preserves references within the cloned data, allowing it to support cyclical and recursive structures that would cause errors for JSON.\r\n\r\n## Support in Node.js: Experimental &#128578;\r\n\r\nThe `v8` module in Node.js currently (as of Node 11) [exposes the structured serialization API directly](https://nodejs.org/api/all.html#v8_serialization_api), but this functionality is still marked as &quot;experimental&quot;, and subject to change or removal in future versions. If you&#39;re using a compatible version, cloning an object is as simple as:\r\n\r\n```lang-js\r\nconst v8 = require(&#39;v8&#39;);\r\n\r\nconst structuredClone = obj =&gt; {\r\n  return v8.deserialize(v8.serialize(obj));\r\n};\r\n```\r\n\r\n## Direct Support in Browsers: Maybe Eventually? &#128528;\r\n\r\nBrowsers do not currently provide a direct interface for the structured cloning algorithm, but a global `structuredClone()` function has been discussed in [whatwg/html#793 on GitHub](https://github.com/whatwg/html/issues/793). As currently proposed, using it for most purposes would be as simple as:\r\n\r\n```lang-js\r\nconst clone = structuredClone(original);\r\n```\r\n\r\nUnless this is shipped, browsers&#39; structured clone implementations are only exposed indirectly.\r\n\r\n## Asynchronous Workaround: Usable. &#128533;\r\n\r\nThe lower-overhead way to create a structured clone with existing APIs is to post the data through one port of a [MessageChannels][3]. The other port will emit a `message` event with a structured clone of the attached `.data`. Unfortunately, listening for these events is necessarily asynchronous, and the synchronous alternatives are less practical.\r\n\r\n```lang-js\r\nclass StructuredCloner {\r\n  constructor() {\r\n    this.pendingClones_ = new Map();\r\n    this.nextKey_ = 0;\r\n    \r\n    const channel = new MessageChannel();\r\n    this.inPort_ = channel.port1;\r\n    this.outPort_ = channel.port2;\r\n    \r\n    this.outPort_.onmessage = ({data: {key, value}}) =&gt; {\r\n      const resolve = this.pendingClones_.get(key);\r\n      resolve(value);\r\n      this.pendingClones_.delete(key);\r\n    };\r\n    this.outPort_.start();\r\n  }\r\n\r\n  cloneAsync(value) {\r\n    return new Promise(resolve =&gt; {\r\n      const key = this.nextKey_++;\r\n      this.pendingClones_.set(key, resolve);\r\n      this.inPort_.postMessage({key, value});\r\n    });\r\n  }\r\n}\r\n\r\nconst structuredCloneAsync = window.structuredCloneAsync =\r\n    StructuredCloner.prototype.cloneAsync.bind(new StructuredCloner);\r\n```\r\n\r\n### Example Use:\r\n\r\n```lang-js\r\nconst main = async () =&gt; {\r\n  const original = { date: new Date(), number: Math.random() };\r\n  original.self = original;\r\n\r\n  const clone = await structuredCloneAsync(original);\r\n\r\n  // They&#39;re different objects:\r\n  console.assert(original !== clone);\r\n  console.assert(original.date !== clone.date);\r\n\r\n  // They&#39;re cyclical:\r\n  console.assert(original.self === original);\r\n  console.assert(clone.self === clone);\r\n\r\n  // They contain equivalent values:\r\n  console.assert(original.number === clone.number);\r\n  console.assert(Number(original.date) === Number(clone.date));\r\n  \r\n  console.log(&quot;Assertions complete.&quot;);\r\n};\r\n\r\nmain();\r\n```\r\n\r\n## Synchronous Workarounds: Awful! &#129314;\r\n\r\nThere are no good options for creating structured clones synchronously. Here are a couple of impractical hacks instead.\r\n\r\n`history.pushState()` and `history.replaceState()` both create a structured clone of their first argument, and assign that value to `history.state`. You can use this to create a structured clone of any object like this:\r\n\r\n```lang-js\r\nconst structuredClone = obj =&gt; {\r\n  const oldState = history.state;\r\n  history.replaceState(obj, null);\r\n  const clonedObj = history.state;\r\n  history.replaceState(oldState, null);\r\n  return clonedObj;\r\n};\r\n```\r\n\r\n### Example Use:\r\n\r\n&lt;!-- begin snippet: js hide: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    &#39;use strict&#39;;\r\n\r\n    const main = () =&gt; {\r\n      const original = { date: new Date(), number: Math.random() };\r\n      original.self = original;\r\n    \r\n      const clone = structuredClone(original);\r\n      \r\n      // They&#39;re different objects:\r\n      console.assert(original !== clone);\r\n      console.assert(original.date !== clone.date);\r\n    \r\n      // They&#39;re cyclical:\r\n      console.assert(original.self === original);\r\n      console.assert(clone.self === clone);\r\n    \r\n      // They contain equivalent values:\r\n      console.assert(original.number === clone.number);\r\n      console.assert(Number(original.date) === Number(clone.date));\r\n      \r\n      console.log(&quot;Assertions complete.&quot;);\r\n    };\r\n\r\n    const structuredClone = obj =&gt; {\r\n      const oldState = history.state;\r\n      history.replaceState(obj, null);\r\n      const clonedObj = history.state;\r\n      history.replaceState(oldState, null);\r\n      return clonedObj;\r\n    };\r\n\r\n    main();\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nThough synchronous, this can be extremely slow. It incurs all of the overhead associated with manipulating the browser history. Calling this method repeatedly can cause Chrome to become temporarily unresponsive.\r\n\r\nThe [`Notification` constructor](https://developer.mozilla.org/en-US/docs/Web/API/Notification/Notification) creates a structured clone of its associated data. It also attempts to display a browser notification to the user, but this will silently fail unless you have requested notification permission. In case you have the permission for other purposes, we&#39;ll immediately close the notification we&#39;ve created.\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    const structuredClone = obj =&gt; {\r\n      const n = new Notification(&#39;&#39;, {data: obj, silent: true});\r\n      n.onshow = n.close.bind(n);\r\n      return n.data;\r\n    };\r\n\r\n\r\n### Example Use:\r\n\r\n&lt;!-- begin snippet: js hide: true --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    &#39;use strict&#39;;\r\n\r\n    const main = () =&gt; {\r\n      const original = { date: new Date(), number: Math.random() };\r\n      original.self = original;\r\n    \r\n      const clone = structuredClone(original);\r\n      \r\n      // They&#39;re different objects:\r\n      console.assert(original !== clone);\r\n      console.assert(original.date !== clone.date);\r\n    \r\n      // They&#39;re cyclical:\r\n      console.assert(original.self === original);\r\n      console.assert(clone.self === clone);\r\n    \r\n      // They contain equivalent values:\r\n      console.assert(original.number === clone.number);\r\n      console.assert(Number(original.date) === Number(clone.date));\r\n      \r\n      console.log(&quot;Assertions complete.&quot;);\r\n    };\r\n\r\n    const structuredClone = obj =&gt; {\r\n      const n = new Notification(&#39;&#39;, {data: obj, silent: true});\r\n      n.close();\r\n      return n.data;\r\n    };\r\n\r\n    main();\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n  [1]: https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel\r\n  [5]: https://developer.mozilla.org/en/DOM/window.postMessage\r\n"},{"score":-4,"body_markdown":"    function clone(obj)\r\n    {\r\n        var cloneObj = Object.create(obj);\r\n\r\n        return cloneObj;\r\n    }\r\n\r\nIn Javascript objects individually inherit another object (Prototypal inheritance). Object.create(obj) returns an object that is a sub-object or child object of obj. In the above function it will effectively return a copy of the object.\r\n\r\nHowever, This is a very odd way to clone because I am not using inheritance for its real purpose."},{"score":0,"body_markdown":"I came to this page due to the same question but I&#39;m neither using JQuery and none of the clone-Methods worked for my own objects.\r\n\r\nI&#39;m aware my answer isn&#39;t related too strong to this question because it&#39;s a different approach. Instead of using clone-functions I use a create function. It worked for me for the following (unfortunately restricting) purposes:\r\n\r\n 1. I use mostly JSP-generated Javascript\r\n 2. I know in the beginning which Object must be generated (In my case it&#39;s Information from a Database which gets fetched once and needs to be deployed more often in the JS.\r\n\r\nFirst I defined my Objects like this:\r\n\r\n    var obj= new Object();\r\n    obj.Type=&#39;Row&#39;;\r\n    obj.ID=1;\r\n    obj.Value=&#39;Blah blah&#39;;\r\n\r\nNow I moved everything like:\r\n\r\n    function getObjSelektor(id_nummer,selected){\r\n    var obj = document.createElement(&quot;select&quot;);\r\n    obj.setAttribute(&quot;id&quot;,&quot;Selektor_&quot;+id_nummer);\r\n    obj.setAttribute(&quot;name&quot;,&quot;Selektor&quot;);\r\n    obj.setAttribute(&quot;size&quot;,&quot;1&quot;);\r\n    \r\n    var obj_opt_1 = document.createElement(&quot;option&quot;);\r\n    obj_opt_1.setAttribute(&quot;value&quot;,&quot;1&quot;);\r\n    if(1==selected)\r\n        posopval_opt_1.setAttribute(&quot;selected&quot;,&quot;selected&quot;);\r\n    obj_opt_1.innerHTML=&quot;Blah blah&quot;;\r\n    obj.appendChild(obj_opt_1);\r\n    \r\n    var obj_opt_2 = document.createElement(&quot;option&quot;);\r\n    obj_opt_2.setAttribute(&quot;value&quot;,&quot;2&quot;);\r\n    if(2==selected)\r\n        obj_opt_2.setAttribute(&quot;selected&quot;,&quot;selected&quot;);\r\n    obj_opt_2.innerHTML=&quot;2nd Row&quot;;\r\n    obj.appendChild(obj_opt_2);\r\n    \r\n    ...\r\n    \r\n    return obj;\r\n    }\r\n\r\nAnd call the function in the regular code:\r\n\r\n    myDiv.getObjSelektor(getObjSelektor(anotherObject.ID));\r\n\r\n\r\nAs said this is a different approach which solved my issue for my purposes. "},{"score":0,"body_markdown":"If you got an Object with Functions you can do it with JSONfn, see http://www.eslinstructor.net/jsonfn/.\r\n\r\n    var obj= {\r\n        name:&#39;Marvin&#39;,\r\n        getName :  function(){\r\n          return this.name;\r\n        }\r\n    }\r\n    var cobj = JSONfn.parse(JSONfn.stringify(obj));\r\n\r\n"},{"score":3,"body_markdown":"You can use functional closure to gain all the benefits of a deep copy, without a deep copy. It&#39;s a very different paradigm, but works well. Instead of trying to copy an existing object, just use a function to instantiate a new object when you need one.\r\n\r\nFirst, create an function that returns an object\r\n\r\n    function template() {\r\n      return {\r\n        values: [1, 2, 3],\r\n        nest: {x: {a: &quot;a&quot;, b: &quot;b&quot;}, y: 100}\r\n      };\r\n    }\r\n\r\nThen create a simple shallow copy function\r\n\r\n    function copy(a, b) {\r\n      Object.keys(b).forEach(function(key) {\r\n        a[key] = b[key];\r\n      });\r\n    }\r\n\r\nCreate a new object, and copy the template&#39;s properties onto it\r\n\r\n    var newObject = {}; \r\n    copy(newObject, template());\r\n\r\nBut the above copy step is not necessary. All you need to do is this:\r\n\r\n    var newObject = template();\r\n\r\nNow that you have a new object, test to see what its properties are:\r\n\r\n    console.log(Object.keys(newObject));\r\n\r\nThis displays:\r\n\r\n    [&quot;values&quot;, &quot;nest&quot;]\r\n\r\nYes, those are the newObject&#39;s own properties, not references to properties on another object.\r\nLet&#39;s just check:\r\n\r\n    console.log(newObject.nest.x.b);\r\n\r\nThis displays:\r\n\r\n    &quot;b&quot;\r\n\r\nThe newObject has acquired all of the template object&#39;s properties, but is free of any dependency chain.\r\n\r\nhttp://jsbin.com/ISUTIpoC/1/edit?js,console\r\n\r\nI added this example to encourage some debate, so please add some comments :)\r\n"},{"score":0,"body_markdown":"The problem with copying an object that, eventually, may point at itself, can be solved with a simple check. Add this check, every time there is a copy action. It may be **slow**, but it *should* work.\r\n\r\nI use a **toType()** function to return the object type, explicitly. I also have my own **copyObj()** function, which is rather similar in logic, which answers all three Object(), Array(), and Date() cases.\r\n\r\nI run it in NodeJS.\r\n\r\n**NOT TESTED, YET.**\r\n\r\n    // Returns true, if one of the parent&#39;s children is the target.\r\n    // This is useful, for avoiding copyObj() through an infinite loop!\r\n    function isChild(target, parent) {\r\n      if (toType(parent) == &#39;[object Object]&#39;) {\r\n        for (var name in parent) {\r\n          var curProperty = parent[name];\r\n          \r\n          // Direct child.\r\n          if (curProperty = target) return true;\r\n          \r\n          // Check if target is a child of this property, and so on, recursively.\r\n          if (toType(curProperty) == &#39;[object Object]&#39; || toType(curProperty) == &#39;[object Array]&#39;) {\r\n            if (isChild(target, curProperty)) return true;\r\n          }\r\n        }\r\n      } else if (toType(parent) == &#39;[object Array]&#39;) {\r\n        for (var i=0; i &lt; parent.length; i++) {\r\n          var curItem = parent[i];\r\n          \r\n          // Direct child.\r\n          if (curItem = target) return true;\r\n          \r\n          // Check if target is a child of this property, and so on, recursively.\r\n          if (toType(curItem) == &#39;[object Object]&#39; || toType(curItem) == &#39;[object Array]&#39;) {\r\n            if (isChild(target, curItem)) return true;\r\n          }\r\n        }\r\n      }\r\n      \r\n      return false;     // Not the target.\r\n    }"},{"score":90,"body_markdown":"There are several issues with most solutions on the internet. So I decided to make a follow-up, which includes, why the accepted answer shouldn&#39;t be accepted.\r\n\r\n## starting situation ##\r\n\r\nI want to **deep-copy** a Javascript `Object` with all of its children and their children and so on. But since I&#39;m not kind of a normal developer, my `Object` has *normal* `properties`, `circular structures` and even `nested objects`.\r\n\r\nSo let&#39;s create a `circular structure` and a `nested object` first.\r\n\r\n    function Circ() {\r\n        this.me = this;\r\n    }\r\n\r\n    function Nested(y) {\r\n        this.y = y;\r\n    }\r\n\r\nLet&#39;s bring everything together in an `Object` named `a`.\r\n\r\n    var a = {\r\n        x: &#39;a&#39;,\r\n        circ: new Circ(),\r\n        nested: new Nested(&#39;a&#39;)\r\n    };\r\n\r\nNext, we want to copy `a` into a variable named `b` and mutate it.\r\n\r\n    var b = a;\r\n\r\n    b.x = &#39;b&#39;;\r\n    b.nested.y = &#39;b&#39;;\r\n\r\nYou know what happened here because if not you wouldn&#39;t even land on this great question.\r\n\r\n    console.log(a, b);\r\n    \r\n    a --&gt; Object {\r\n        x: &quot;b&quot;,\r\n        circ: Circ {\r\n            me: Circ { ... }\r\n        },\r\n        nested: Nested {\r\n            y: &quot;b&quot;\r\n        }\r\n    }\r\n    \r\n    b --&gt; Object {\r\n        x: &quot;b&quot;,\r\n        circ: Circ {\r\n            me: Circ { ... }\r\n        },\r\n        nested: Nested {\r\n            y: &quot;b&quot;\r\n        }\r\n    }\r\n    \r\nNow let&#39;s find a solution.\r\n\r\n## JSON ##\r\n\r\nThe first attempt I tried was using `JSON`.\r\n\r\n    var b = JSON.parse( JSON.stringify( a ) );\r\n    \r\n    b.x = &#39;b&#39;;\r\n    b.nested.y = &#39;b&#39;;\r\n    \r\nDon&#39;t waste too much time on it, you&#39;ll get `TypeError: Converting circular structure to JSON`.\r\n\r\n## Recursive copy *(the accepted &quot;answer&quot;)* ##\r\n\r\nLet&#39;s have a look at the accepted answer.\r\n\r\n    function cloneSO(obj) {\r\n        // Handle the 3 simple types, and null or undefined\r\n        if (null == obj || &quot;object&quot; != typeof obj) return obj;\r\n\r\n        // Handle Date\r\n        if (obj instanceof Date) {\r\n            var copy = new Date();\r\n            copy.setTime(obj.getTime());\r\n            return copy;\r\n        }\r\n\r\n        // Handle Array\r\n        if (obj instanceof Array) {\r\n            var copy = [];\r\n            for (var i = 0, len = obj.length; i &lt; len; i++) {\r\n                copy[i] = cloneSO(obj[i]);\r\n            }\r\n            return copy;\r\n        }\r\n\r\n        // Handle Object\r\n        if (obj instanceof Object) {\r\n            var copy = {};\r\n            for (var attr in obj) {\r\n                if (obj.hasOwnProperty(attr)) copy[attr] = cloneSO(obj[attr]);\r\n            }\r\n            return copy;\r\n        }\r\n\r\n        throw new Error(&quot;Unable to copy obj! Its type isn&#39;t supported.&quot;);\r\n    }\r\n    \r\nLooks good, heh? It&#39;s a recursive copy of the object and handles other types as well, like `Date`, but that wasn&#39;t a requirement.\r\n\r\n    var b = cloneSO(a);\r\n    \r\n    b.x = &#39;b&#39;;\r\n    b.nested.y = &#39;b&#39;;\r\n    \r\nRecursion and `circular structures` doesn&#39;t work well together... `RangeError: Maximum call stack size exceeded`\r\n\r\n## native solution ##\r\n\r\nAfter arguing with my co-worker, my boss asked us what happened, and he found a simple *solution* after some googling. It&#39;s called `Object.create`.\r\n\r\n    var b = Object.create(a);\r\n    \r\n    b.x = &#39;b&#39;;\r\n    b.nested.y = &#39;b&#39;;\r\n    \r\nThis solution was added to Javascript some time ago and even handles `circular structure`.\r\n\r\n    console.log(a, b);\r\n    \r\n    a --&gt; Object {\r\n        x: &quot;a&quot;,\r\n        circ: Circ {\r\n            me: Circ { ... }\r\n        },\r\n        nested: Nested {\r\n            y: &quot;b&quot;\r\n        }\r\n    }\r\n    \r\n    b --&gt; Object {\r\n        x: &quot;b&quot;,\r\n        circ: Circ {\r\n            me: Circ { ... }\r\n        },\r\n        nested: Nested {\r\n            y: &quot;b&quot;\r\n        }\r\n    }\r\n\r\n... and you see, it didn&#39;t work with the nested structure inside.\r\n\r\n## polyfill for the native solution ##\r\n\r\nThere&#39;s a polyfill for `Object.create` in the older browser just like the IE 8. It&#39;s something like recommended by Mozilla, and of course, it&#39;s not perfect and results in the same problem as the *native solution*.\r\n\r\n    function F() {};\r\n    function clonePF(o) {\r\n        F.prototype = o;\r\n        return new F();\r\n    }\r\n    \r\n    var b = clonePF(a);\r\n    \r\n    b.x = &#39;b&#39;;\r\n    b.nested.y = &#39;b&#39;;\r\n\r\nI&#39;ve put `F` outside the scope so we can have a look at what `instanceof` tells us.\r\n\r\n    console.log(a, b);\r\n    \r\n    a --&gt; Object {\r\n        x: &quot;a&quot;,\r\n        circ: Circ {\r\n            me: Circ { ... }\r\n        },\r\n        nested: Nested {\r\n            y: &quot;b&quot;\r\n        }\r\n    }\r\n    \r\n    b --&gt; F {\r\n        x: &quot;b&quot;,\r\n        circ: Circ {\r\n            me: Circ { ... }\r\n        },\r\n        nested: Nested {\r\n            y: &quot;b&quot;\r\n        }\r\n    }\r\n    \r\n    console.log(typeof a, typeof b);\r\n    \r\n    a --&gt; object\r\n    b --&gt; object\r\n    \r\n    console.log(a instanceof Object, b instanceof Object);\r\n    \r\n    a --&gt; true\r\n    b --&gt; true\r\n    \r\n    console.log(a instanceof F, b instanceof F);\r\n\r\n    a --&gt; false\r\n    b --&gt; true\r\n    \r\nSame problem as the *native solution*, but a little bit worse output.\r\n\r\n## the better (but not perfect) solution ##\r\n\r\nWhen digging around, I found a similar question (https://stackoverflow.com/questions/10728412/in-javascript-when-performing-a-deep-copy-how-do-i-avoid-a-cycle-due-to-a-pro) to this one, but with a way better solution.\r\n\r\n    function cloneDR(o) {\r\n        const gdcc = &quot;__getDeepCircularCopy__&quot;;\r\n        if (o !== Object(o)) {\r\n            return o; // primitive value\r\n        }\r\n\r\n        var set = gdcc in o,\r\n            cache = o[gdcc],\r\n            result;\r\n        if (set &amp;&amp; typeof cache == &quot;function&quot;) {\r\n            return cache();\r\n        }\r\n        // else\r\n        o[gdcc] = function() { return result; }; // overwrite\r\n        if (o instanceof Array) {\r\n            result = [];\r\n            for (var i=0; i&lt;o.length; i++) {\r\n                result[i] = cloneDR(o[i]);\r\n            }\r\n        } else {\r\n            result = {};\r\n            for (var prop in o)\r\n                if (prop != gdcc)\r\n                    result[prop] = cloneDR(o[prop]);\r\n                else if (set)\r\n                    result[prop] = cloneDR(cache);\r\n        }\r\n        if (set) {\r\n            o[gdcc] = cache; // reset\r\n        } else {\r\n            delete o[gdcc]; // unset again\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    var b = cloneDR(a);\r\n    \r\n    b.x = &#39;b&#39;;\r\n    b.nested.y = &#39;b&#39;;\r\n\r\nAnd let&#39;s have a look at the output...\r\n\r\n    console.log(a, b);\r\n    \r\n    a --&gt; Object {\r\n        x: &quot;a&quot;,\r\n        circ: Object {\r\n            me: Object { ... }\r\n        },\r\n        nested: Object {\r\n            y: &quot;a&quot;\r\n        }\r\n    }\r\n    \r\n    b --&gt; Object {\r\n        x: &quot;b&quot;,\r\n        circ: Object {\r\n            me: Object { ... }\r\n        },\r\n        nested: Object {\r\n            y: &quot;b&quot;\r\n        }\r\n    }\r\n    \r\n    console.log(typeof a, typeof b);\r\n    \r\n    a --&gt; object\r\n    b --&gt; object\r\n    \r\n    console.log(a instanceof Object, b instanceof Object);\r\n    \r\n    a --&gt; true\r\n    b --&gt; true\r\n    \r\n    console.log(a instanceof F, b instanceof F);\r\n\r\n    a --&gt; false\r\n    b --&gt; false\r\n    \r\nThe requirements are matched, but there are still some smaller issues, including changing the `instance` of `nested` and `circ` to `Object`.\r\n\r\n&gt; The structure of trees that share a leaf won&#39;t be copied, they will become two independent leaves:\r\n\r\n            [Object]                     [Object]\r\n             /    \\                       /    \\\r\n            /      \\                     /      \\\r\n          |/_      _\\|                 |/_      _\\|  \r\n      [Object]    [Object]   ===&gt;  [Object]    [Object]\r\n           \\        /                 |           |\r\n            \\      /                  |           |\r\n            _\\|  |/_                 \\|/         \\|/\r\n            [Object]               [Object]    [Object]\r\n\r\n## conclusion ##\r\n\r\nThe last solution using recursion and a cache, may not be the best, but it&#39;s a **real** deep-copy of the object. It handles simple `properties`, `circular structures` and `nested object`, but it will mess up the instance of them while cloning.\r\n\r\n[jsfiddle](http://jsfiddle.net/einfallstoll/N4mr2/)\r\n\r\n"},{"score":27,"body_markdown":"For those using AngularJS, there is also direct method for cloning or extending of the objects in this library.\r\n\r\n    var destination = angular.copy(source);\r\n\r\nor\r\n\r\n    angular.copy(source, destination);\r\n\r\nMore in angular.copy [documentation][1]...\r\n\r\n\r\n  [1]: https://docs.angularjs.org/api/ng/function/angular.copy"},{"score":2,"body_markdown":"\r\nI&#39;ve tried this in the case of a scalar object and it works for me:\r\n\r\n    function binder(i) {\r\n      return function () {\r\n        return i;\r\n      };\r\n    }\r\n    \r\n    a=1;\r\n    b=binder(a)(); // copy value of a into b\r\n    \r\n    alert(++a); // 2\r\n    alert(b); // still 1\r\n\r\nRegards."},{"score":6,"body_markdown":"I&#39;ve written my own implementation. Not sure if it counts as a better solution:\r\n\r\n    /*\r\n        a function for deep cloning objects that contains other nested objects and circular structures.\r\n        objects are stored in a 3D array, according to their length (number of properties) and their depth in the original object.\r\n                                        index (z)\r\n                                             |\r\n                                             |\r\n                                             |\r\n                                             |\r\n                                             |\r\n                                             |                      depth (x)\r\n                                             |_ _ _ _ _ _ _ _ _ _ _ _\r\n                                            /_/_/_/_/_/_/_/_/_/\r\n                                           /_/_/_/_/_/_/_/_/_/\r\n                                          /_/_/_/_/_/_/...../\r\n                                         /................./\r\n                                        /.....            /\r\n                                       /                 /\r\n                                      /------------------\r\n                object length (y)    /\r\n    */\r\n\r\n\r\nFollowing is the implementation:\r\n\r\n\tfunction deepClone(obj) {\r\n\t\tvar depth = -1;\r\n\t\tvar arr = [];\r\n\t\treturn clone(obj, arr, depth);\r\n\t}\r\n\t\r\n\t/**\r\n\t *\r\n\t * @param obj source object\r\n\t * @param arr 3D array to store the references to objects\r\n\t * @param depth depth of the current object relative to the passed &#39;obj&#39;\r\n\t * @returns {*}\r\n\t */\r\n\tfunction clone(obj, arr, depth){\r\n\t\tif (typeof obj !== &quot;object&quot;) {\r\n\t\t\treturn obj;\r\n\t\t}\r\n\r\n\t\tvar length = Object.keys(obj).length; // native method to get the number of properties in &#39;obj&#39;\r\n\t\r\n\t\tvar result = Object.create(Object.getPrototypeOf(obj)); // inherit the prototype of the original object\r\n\t\tif(result instanceof Array){\r\n\t\t\tresult.length = length;\r\n\t\t}\r\n\t\r\n\t\tdepth++; // depth is increased because we entered an object here\r\n\t\t\r\n\t\tarr[depth] = []; // this is the x-axis, each index here is the depth\r\n\t\tarr[depth][length] = []; // this is the y-axis, each index is the length of the object (aka number of props)\r\n\t\t// start the depth at current and go down, cyclic structures won&#39;t form on depths more than the current one\r\n\t\tfor(var x = depth; x &gt;= 0; x--){\r\n\t\t\t// loop only if the array at this depth and length already have elements\r\n\t\t\tif(arr[x][length]){\r\n\t\t\t\tfor(var index = 0; index &lt; arr[x][length].length; index++){\r\n\t\t\t\t\tif(obj === arr[x][length][index]){\r\n\t\t\t\t\t\treturn obj;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tarr[depth][length].push(obj); // store the object in the array at the current depth and length\r\n\t\tfor (var prop in obj) {\r\n\t\t\tif (obj.hasOwnProperty(prop)) result[prop] = clone(obj[prop], arr, depth);\r\n\t\t}\r\n\t\r\n\t\treturn result;\r\n\t}\r\n"},{"score":3,"body_markdown":"Clone an object based on a `template`. What do you do if you don&#39;t want an exact copy, but you do want the robustness of some kind of reliable clone operation but you only want bits cloned or you want to make sure you can control the existence or format of each attribute value cloned?\r\n\r\nI am contributing this because it&#39;s useful for us and we created it because we could not find something similar. You can use it to clone an object based on a `template` object which specifies what attributes of the object I want to clone, and the template allows for functions to transform those attributes into something different if they don&#39;t exist on the source object or however you want to handle the clone. If it&#39;s not useful I am sure someone can delete this answer.\r\n\r\n       function isFunction(functionToCheck) {\r\n           var getType = {};\r\n           return functionToCheck &amp;&amp; getType.toString.call(functionToCheck) === &#39;[object Function]&#39;;\r\n       }\r\n    \r\n       function cloneObjectByTemplate(obj, tpl, cloneConstructor) {\r\n           if (typeof cloneConstructor === &quot;undefined&quot;) {\r\n               cloneConstructor = false;\r\n           }\r\n           if (obj == null || typeof (obj) != &#39;object&#39;) return obj;\r\n    \r\n           //if we have an array, work through it&#39;s contents and apply the template to each item...\r\n           if (Array.isArray(obj)) {\r\n               var ret = [];\r\n               for (var i = 0; i &lt; obj.length; i++) {\r\n                   ret.push(cloneObjectByTemplate(obj[i], tpl, cloneConstructor));\r\n               }\r\n               return ret;\r\n           }\r\n    \r\n           //otherwise we have an object...\r\n           //var temp:any = {}; // obj.constructor(); // we can&#39;t call obj.constructor because typescript defines this, so if we are dealing with a typescript object it might reset values.\r\n           var temp = cloneConstructor ? new obj.constructor() : {};\r\n    \r\n           for (var key in tpl) {\r\n               //if we are provided with a function to determine the value of this property, call it...\r\n               if (isFunction(tpl[key])) {\r\n                   temp[key] = tpl[key](obj); //assign the result of the function call, passing in the value\r\n               } else {\r\n                   //if our object has this property...\r\n                   if (obj[key] != undefined) {\r\n                       if (Array.isArray(obj[key])) {\r\n                           temp[key] = [];\r\n                           for (var i = 0; i &lt; obj[key].length; i++) {\r\n                               temp[key].push(cloneObjectByTemplate(obj[key][i], tpl[key], cloneConstructor));\r\n                           }\r\n                       } else {\r\n                           temp[key] = cloneObjectByTemplate(obj[key], tpl[key], cloneConstructor);\r\n                       }\r\n                   }\r\n               }\r\n           }\r\n    \r\n           return temp;\r\n       }\r\n\r\n\r\nA simple way to call it would be like this:\r\n\r\n   \r\n\r\n    var source = {\r\n           a: &quot;whatever&quot;,\r\n           b: {\r\n               x: &quot;yeah&quot;,\r\n               y: &quot;haha&quot;\r\n           }\r\n       };\r\n       var template = {\r\n           a: true, //we want to clone &quot;a&quot;\r\n           b: {\r\n               x: true //we want to clone &quot;b.x&quot; too\r\n           }\r\n       }; \r\n       var destination = cloneObjectByTemplate(source, template);\r\n\r\nIf you wanted to use a function to make sure an attribute is returned or to make sure it&#39;s a particular type, use a template like this. Instead of using `{ ID: true }` we are providing a function which still just copies the `ID attribute` of the source object but it makes sure that it&#39;s a number even if it does not exist on the source object.\r\n\r\n     var template = {\r\n        ID: function (srcObj) {\r\n            if(srcObj.ID == undefined){ return -1; }\r\n            return parseInt(srcObj.ID.toString());\r\n        }\r\n    }\r\n\r\nArrays will clone fine but if you want to you can have your own function handle those individual attributes too, and do something special like this:\r\n\r\n     var template = {\r\n        tags: function (srcObj) {\r\n            var tags = [];\r\n            if (process.tags != undefined) {\r\n                for (var i = 0; i &lt; process.tags.length; i++) {\r\n\r\n                    tags.push(cloneObjectByTemplate(\r\n                      srcObj.tags[i],\r\n                      { a : true, b : true } //another template for each item in the array\r\n                    );\r\n                }\r\n            }\r\n            return tags;\r\n        }\r\n     }\r\n\r\nSo in the above, our template just copies the `tags` attribute of the source object if it exists, (it&#39;s assumed to be an array), and for each element in that array the clone function is called to individually clone it based on a second template which just copies the `a` and `b` attributes of each of those tag elements. \r\n\r\nIf you are taking objects in and out of node and you want to control which attributes of those objects are cloned then this is a great way of controlling that in `node.js` and the code works in the browser too.\r\n\r\nHere is an example of it&#39;s use: http://jsfiddle.net/hjchyLt1/"},{"score":718,"body_markdown":"In ECMAScript 6 there is [Object.assign][1] method, which copies values of all enumerable own properties from one object to another. For example:\r\n\r\n    var x = {myProp: &quot;value&quot;};\r\n    var y = Object.assign({}, x); \r\nBut be aware that nested objects are still copied as reference.\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"},{"score":16,"body_markdown":"Interested in cloning simple objects:\r\n\r\n`JSON.parse(JSON.stringify(json_original));`\r\n\r\nSource : [https://stackoverflow.com/questions/18359093/how-to-copy-javascript-object-to-new-variable-not-by-reference?answertab=votes#tab-top][1]\r\n\r\n\r\n  [1]: https://stackoverflow.com/questions/18359093/how-to-copy-javascript-object-to-new-variable-not-by-reference?answertab=votes#tab-top"},{"score":135,"body_markdown":"# An elegant way to clone a Javascript object in one line of code\n\nAn `Object.assign` method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need.\n\n    var clone = Object.assign({}, obj);\n\n&gt;The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.\n\n[Read more...](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n\nThe __polyfill__ to support older browsers:\n\n    if (!Object.assign) {\n      Object.defineProperty(Object, &#39;assign&#39;, {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function(target) {\n          &#39;use strict&#39;;\n          if (target === undefined || target === null) {\n            throw new TypeError(&#39;Cannot convert first argument to object&#39;);\n          }\n    \n          var to = Object(target);\n          for (var i = 1; i &lt; arguments.length; i++) {\n            var nextSource = arguments[i];\n            if (nextSource === undefined || nextSource === null) {\n              continue;\n            }\n            nextSource = Object(nextSource);\n    \n            var keysArray = Object.keys(nextSource);\n            for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) {\n              var nextKey = keysArray[nextIndex];\n              var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n              if (desc !== undefined &amp;&amp; desc.enumerable) {\n                to[nextKey] = nextSource[nextKey];\n              }\n            }\n          }\n          return to;\n        }\n      });\n    }"},{"score":36,"body_markdown":"You can simply use a [spread property](https://github.com/sebmarkbage/ecmascript-rest-spread/blob/master/Spread.md) to copy an object without references. But be careful (see comments), the &#39;copy&#39; is just on the lowest object/array level. Nested properties are still references!\r\n\r\n----------\r\n\r\n**Complete clone:**\r\n\r\n    let x = {a: &#39;value1&#39;}\r\n    let x2 = {...x}\r\n\r\n    // =&gt; mutate without references:\r\n\r\n    x2.a = &#39;value2&#39;\r\n    console.log(x.a)    // =&gt; &#39;value1&#39;\r\n\r\n**Clone with references on second level:**\r\n\r\n    const y = {a: {b: &#39;value3&#39;}}\r\n    const y2 = {...y}\r\n\r\n    // =&gt; nested object is still a references:\r\n\r\n    y2.a.b = &#39;value4&#39;\r\n    console.log(y.a.b)    // =&gt; &#39;value4&#39;\r\n\r\n----------\r\n\r\nJavaScript actually does not support deep clones natively. Use an utility function. For example Ramda:\r\n\r\n&gt; http://ramdajs.com/docs/#clone"},{"score":0,"body_markdown":"To handle circular objects that that `JSON.stringify` can&#39;t handle, you can bring in a library called [JSOG][1], that serializes and deserializes arbitrary graphs into JSON format. \r\n\r\n    var clone = JSOG.parse(JSOG.stringify(original));\r\n\r\nIt might also be interesting to try patching JSOG for cloning with this trick (don&#39;t have time at the moment, but if someone wants to give it a shot...):\r\n\r\nSerialize a simple function : \r\n\r\n    foo.f = function(a) { return a }\r\n    var stringForm = foo.f.toString() // &quot;function (a) { return a }&quot;\r\n\r\nDeserialize a function :\r\n\r\n    eval(&quot;foo.f = &quot; + stringForm)\r\n\r\nSome conventions (probably in the name of the property) to identify functions vs regular strings would be needed (`@func_f` perhaps). \r\n\r\nOf course if the function calls a second function the second function will need to exist just as it would for the original.\r\n\r\nThe above however is quite dangerous if you are to accept the serialized form from an untrusted source, but then accepting any function in any form from an untrusted source would be dangerous, so if you&#39;re interested in cloning functions trust must have already been established (or you&#39;re already intent on writing a security flaw!).\r\n\r\n**Disclaimer:** I have not tested the speed of JSOG stringify/parse vs JSON stringify/parse, but It does work on the simple (circular) objects I tested it with.\r\n\r\n  [1]: https://github.com/jsog/jsog"},{"score":4,"body_markdown":"Use `deepcopy` from `npm`.  Works in both the browser and in `node` as an `npm module...`\r\n\r\nhttps://www.npmjs.com/package/deepcopy\r\n\r\n`let a = deepcopy(b)`"},{"score":3,"body_markdown":"I think, that **recurrence with caching** is the best what we can do it here without libraries.\r\n\r\nAnd underestimated **WeakMap** comes to the problem of cycles, wherein storing  pairs of references to old and new object can help us to recreate pretty easily whole tree.\r\n\r\nI prevented deep cloning of the DOM elements, probably you don&#39;t want to clone entire page :)\r\n\r\n    function deepCopy(object) {\r\n        const cache = new WeakMap(); // Map of old - new references\r\n    \r\n        function copy(obj) {\r\n            if (typeof obj !== &#39;object&#39; ||\r\n                obj === null ||\r\n                obj instanceof HTMLElement\r\n            )\r\n                return obj; // primitive value or HTMLElement\r\n                   \r\n            if (obj instanceof Date) \r\n                return new Date().setTime(obj.getTime());\r\n    \r\n            if (obj instanceof RegExp) \r\n                return new RegExp(obj.source, obj.flags);\r\n            \r\n            if (cache.has(obj)) \r\n                return cache.get(obj);\r\n\r\n            const result = obj instanceof Array ? [] : {};\r\n    \r\n            cache.set(obj, result); // store reference to object before the recursive starts\r\n\r\n            if (obj instanceof Array) {\r\n                for(const o of obj) {\r\n                     result.push(copy(o));\r\n                }\r\n                return result;\r\n            }\r\n    \r\n            const keys = Object.keys(obj); \r\n    \r\n            for (const key of keys)\r\n                result[key] = copy(obj[key]);\r\n    \r\n            return result;\r\n        }\r\n    \r\n        return copy(object);\r\n    }\r\n\r\nSome tests:\r\n\r\n    // #1\r\n    const obj1 = { };\r\n    const obj2 = { };\r\n    obj1.obj2 = obj2;\r\n    obj2.obj1 = obj1; // Trivial circular reference\r\n\r\n    var copy = deepCopy(obj1);\r\n    copy == obj1 // false\r\n    copy.obj2 === obj1.obj2 // false\r\n    copy.obj2.obj1.obj2 // and so on - no error (correctly cloned).\r\n\r\n    // #2\r\n    const obj = { x: 0 }\r\n    const clone = deepCopy({ a: obj, b: obj });\r\n    clone.a == clone.b // true\r\n\r\n    // #3\r\n    const arr = [];\r\n    arr[0] = arr; // A little bit weird but who cares\r\n    clone = deepCopy(arr)\r\n    clone == arr // false;\r\n    clone[0][0][0][0] == clone // true;\r\n\r\nNOTE: I&#39;m using constants, for of loop, =&gt; operator and WeakMaps to create more essential code. This syntax (ES6) is supported by today&#39;s browsers"},{"score":257,"body_markdown":"Per [MDN][1]:\r\n\r\n - If you want shallow copy, use `Object.assign({}, a)`\r\n - For &quot;deep&quot; copy, use `JSON.parse(JSON.stringify(a))`\r\n\r\nThere is no need for external libraries but you need to check [browser compatibility first][2].\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Deep_Clone\r\n  [2]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility"},{"score":13,"body_markdown":"New answer to an old question!  If you have the pleasure of having using ECMAScript 2016 (ES6) with [Spread Syntax][1], it&#39;s easy.\r\n\r\n\r\n    keepMeTheSame = {first: &quot;Me!&quot;, second: &quot;You!&quot;};\r\n    cloned = {...keepMeTheSame}\r\n\r\nThis provides a clean method for a shallow copy of an object.  Making a deep copy, meaning makign a new copy of every value in every recursively nested object, requires on of the heavier solutions above.\r\n\r\nJavaScript keeps evolving.\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator"},{"score":1,"body_markdown":"Ok so this might be the very best option for shallow copying.  If follows the many examples using assign, but it also keeps the inheritance and prototype. It&#39;s so simple too and works for most array-like and Objects except those with constructor requirements or read-only properties. But that means it fails miserably for TypedArrays, RegExp, Date, Maps, Sets and Object versions of primitives (Boolean, String, etc..).\r\n\r\n    function copy ( a ) { return Object.assign( new a.constructor, a ) }\r\n\r\nWhere `a` can be any Object or class constructed instance, but again not be reliable for thingies that use specialized getters and setters or have constructor requirements, but for more simple situations it rocks.  It does work on arguments as well.  \r\n\r\nYou can also apply it to primitives to get strange results, but then...  unless it just ends up being a useful hack, who cares.\r\n\r\nresults from basic built-in Object and Array...\r\n\r\n    &gt; a = { a: &#39;A&#39;, b: &#39;B&#39;, c: &#39;C&#39;, d: &#39;D&#39; }\r\n    { a: &#39;A&#39;, b: &#39;B&#39;, c: &#39;C&#39;, d: &#39;D&#39; }\r\n    &gt; b = copy( a )\r\n    { a: &#39;A&#39;, b: &#39;B&#39;, c: &#39;C&#39;, d: &#39;D&#39; }\r\n    &gt; a = [1,2,3,4]\r\n    [ 1, 2, 3, 4 ]\r\n    &gt; b = copy( a )\r\n    [ 1, 2, 3, 4 ]\r\n\r\nAnd fails because of mean get/setters, constructor required arguments or read-only properties, and sins against the father.\r\n\r\n    &gt; a = /\\w+/g\r\n    /\\w+/g\r\n    &gt; b = copy( a )  // fails because source and flags are read-only\r\n    /(?:)/\r\n    &gt; a = new Date ( &#39;1/1/2001&#39; )\r\n    2000-12-31T16:00:00.000Z\r\n    &gt; b = copy( a )  // fails because Date using methods to get and set things\r\n    2017-02-04T14:44:13.990Z\r\n    &gt; a = new Boolean( true )\r\n    [Boolean: true]\r\n    &gt; b = copy( a )  // fails because of of sins against the father\r\n    [Boolean: false]\r\n    &gt; a = new Number( 37 )\r\n    [Number: 37]\r\n    &gt; b = copy( a )  // fails because of of sins against the father\r\n    [Number: 0]\r\n    &gt; a = new String( &#39;four score and seven years ago our four fathers&#39; )\r\n    [String: &#39;four score and seven years ago our four fathers&#39;]\r\n    &gt; b = copy( a )  // fails because of of sins against the father\r\n    { [String: &#39;&#39;] &#39;0&#39;: &#39;f&#39;, &#39;1&#39;: &#39;o&#39;, &#39;2&#39;: &#39;u&#39;, &#39;3&#39;: &#39;r&#39;, &#39;4&#39;: &#39; &#39;, &#39;5&#39;: &#39;s&#39;, &#39;6&#39;: &#39;c&#39;, &#39;7&#39;: &#39;o&#39;, &#39;8&#39;: &#39;r&#39;, &#39;9&#39;: &#39;e&#39;, &#39;10&#39;: &#39; &#39;, &#39;11&#39;: &#39;a&#39;, &#39;12&#39;: &#39;n&#39;, &#39;13&#39;: &#39;d&#39;, &#39;14&#39;: &#39; &#39;, &#39;15&#39;: &#39;s&#39;, &#39;16&#39;: &#39;e&#39;, &#39;17&#39;: &#39;v&#39;, &#39;18&#39;: &#39;e&#39;, &#39;19&#39;: &#39;n&#39;, &#39;20&#39;: &#39; &#39;, &#39;21&#39;: &#39;y&#39;, &#39;22&#39;: &#39;e&#39;, &#39;23&#39;: &#39;a&#39;, &#39;24&#39;: &#39;r&#39;, &#39;25&#39;: &#39;s&#39;, &#39;26&#39;: &#39; &#39;, &#39;27&#39;: &#39;a&#39;, &#39;28&#39;: &#39;g&#39;, &#39;29&#39;: &#39;o&#39;, &#39;30&#39;: &#39; &#39;, &#39;31&#39;: &#39;o&#39;, &#39;32&#39;: &#39;u&#39;, &#39;33&#39;: &#39;r&#39;, &#39;34&#39;: &#39; &#39;, &#39;35&#39;: &#39;f&#39;, &#39;36&#39;: &#39;o&#39;, &#39;37&#39;: &#39;u&#39;, &#39;38&#39;: &#39;r&#39;, &#39;39&#39;: &#39; &#39;, &#39;40&#39;: &#39;f&#39;, &#39;41&#39;: &#39;a&#39;, &#39;42&#39;: &#39;t&#39;, &#39;43&#39;: &#39;h&#39;, &#39;44&#39;: &#39;e&#39;, &#39;45&#39;: &#39;r&#39;, &#39;46&#39;: &#39;s&#39; } \r\n\r\n"},{"score":20,"body_markdown":"In ES-6 you can simply use Object.assign(...).\r\nEx:\r\n\r\n    let obj = {person: &#39;Thor Odinson&#39;};\r\n    let clone = Object.assign({}, obj);\r\n\r\nA good reference is here:\r\nhttps://googlechrome.github.io/samples/object-assign-es6/"},{"score":12,"body_markdown":"    let clone = Object.assign( Object.create( Object.getPrototypeOf(obj)), obj)\r\n\r\nES6 solution if you want to (shallow) clone a **class instance** and not just a property object."},{"score":-1,"body_markdown":"Ok, I know it has many answers, but no one pointed out, EcmaScript5 has assign method, work on FF and Chrome, it copies enumerable and own properties and  Symbols.\r\n\r\n[Object Assign][1]\r\n\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"},{"score":67,"body_markdown":"**OK,** imagine you have this object below and you want to clone it:\r\n\r\n    let obj = {a:1, b:2, c:3}; //ES6\r\nor\r\n\r\n    var obj = {a:1, b:2, c:3}; //ES5\r\n\r\n\r\nthe answer is mainly depeneds on which **ECMAscript** you using, in `ES6+`, you can simply use `Object.assign` to do the clone:\r\n\r\n\r\n    let cloned = Object.assign({}, obj); //new {a:1, b:2, c:3};\r\n\r\nor using spread operator like this:\r\n\r\n    let cloned = {...obj}; //new {a:1, b:2, c:3};\r\n\r\nBut if you using `ES5`, you can use few methods, but the `JSON.stringify`, just make sure you not using for a big chunk of data to copy, but it could be one line handy way in many cases, something like this:\r\n\r\n    let cloned = JSON.parse(JSON.stringify(obj)); \r\n    //new {a:1, b:2, c:3};, can be handy, but avoid using on big chunk of data over and over\r\n"},{"score":0,"body_markdown":"I don&#39;t know which cases this doesn&#39;t work for, but it got me a copy of an array. I think its cute :) Hope it helps\r\n\r\n    copiedArr = origArr.filter(function(x){return true})"},{"score":1,"body_markdown":"Here&#39;s a modern solution that doesn&#39;t have the pitfalls of `Object.assign()` (does not copy by reference):\r\n\r\n    const cloneObj = (obj) =&gt; {\r\n        return Object.keys(obj).reduce((dolly, key) =&gt; {\r\n            dolly[key] = (obj[key].constructor === Object) ?\r\n                cloneObj(obj[key]) :\r\n                obj[key];\r\n            return dolly;\r\n        }, {});\r\n    };"},{"score":0,"body_markdown":"If your object is a class (e.g. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes):\r\n\r\n    var copiedObject = jQuery.extend(true, {}, originalObject);\r\n    copiedObject.__proto__ = originalObject.__proto__;\r\n\r\nThen in `copiedObject` you have a deep-copied instance of `originalObject` class with all its methods."},{"score":0,"body_markdown":"If you are using TypeScript, need to support older web browsers (and so can&#39;t use  `Object.assign`), and aren&#39;t using a library with a clone method build in, you can make yourself a `combine` helper in a few lines of code. It combines objects, and if you have only one, just clones it.\r\n\r\n\t/** Creates a new object that combines the properties of the specified objects. */\r\n\tfunction combine(...objs: {}[]) {\r\n\t\tconst combined = {};\r\n\t\tobjs.forEach(o =&gt; Object.keys(o).forEach(p =&gt; combined[p] = o[p]));\r\n\t\treturn combined;\r\n\t}\r\n"},{"score":0,"body_markdown":"You may clone your Object without modification parent Object - \r\n\r\n        /** [Object Extend]*/\r\n    \t( typeof Object.extend === &#39;function&#39; ? undefined : ( Object.extend = function ( destination, source ) {\r\n    \t\tfor ( var property in source )\r\n    \t\t\tdestination[property] = source[property];\r\n    \t\treturn destination;\r\n    \t} ) );\r\n    \t/** [/Object Extend]*/\r\n    \t/** [Object clone]*/\r\n    \t( typeof Object.clone === &#39;function&#39; ? undefined : ( Object.clone = function ( object ) {\r\n    \t\treturn this.extend( {}, object );\r\n    \t} ) );\r\n    \t/** [/Object clone]*/\r\n    \t\r\n    \tlet myObj = {\r\n    \t\ta:1, b:2, c:3, d:{\r\n    \t\t\ta:1, b:2, c:3\r\n    \t\t}\r\n    \t};\r\n    \t\r\n    \tlet clone = Object.clone( myObj );\r\n    \t\r\n    \tclone.a = 10;\r\n    \t\r\n    \tconsole.log(&#39;clone.a==&gt;&#39;, clone.a); //==&gt; 10\r\n    \t\r\n    \tconsole.log(&#39;myObj.a==&gt;&#39;, myObj.a); //==&gt; 1 // object not modified here\r\n    \t\r\n    \tlet clone2 = Object.clone( clone );\r\n    \t\r\n    \tclone2.a = 20;\r\n    \t\r\n    \tconsole.log(&#39;clone2.a==&gt;&#39;, clone2.a); //==&gt; 20\r\n    \t\r\n    \tconsole.log(&#39;clone.a==&gt;&#39;, clone.a); //==&gt; 10 // object not modified here"},{"score":0,"body_markdown":"I&#39;m providing an answer to this question, because I do not see any native, recursive implementations here that resolve the problem of `DOM` elements.\r\n\r\nThe problem there is that `&lt;element&gt;` has `parent` and `child` attributes, that link to other elements with `parent` and `child` values, which point back to the original `&lt;element&gt;`, causing either an **infinite recursive** or **cyclic redundancy**.\r\n\r\nIf your object is something safe and simple like\r\n\r\n    {\r\n        &#39;123&#39;:456\r\n    }\r\n\r\n...then any other answer here will probably work.\r\n\r\nBut if you have...\r\n\r\n    {\r\n        &#39;123&#39;:&lt;reactJSComponent&gt;,\r\n        &#39;456&#39;:document.createElement(&#39;div&#39;),\r\n    }\r\n\r\n...then you need something like this:\r\n\r\n        // cloneVariable() : Clone variable, return null for elements or components.\r\n    var cloneVariable = function (args) {\r\n        const variable = args.variable;\r\n\r\n        if(variable === null) {\r\n                return null;\r\n        }\r\n\r\n        if(typeof(variable) === &#39;object&#39;) {\r\n                if(variable instanceof HTMLElement || variable.nodeType &gt; 0) {\r\n                        return null;\r\n                }\r\n\r\n                if(Array.isArray(variable)) {\r\n                        var arrayclone = [];\r\n\r\n                        variable.forEach((element) =&gt; {\r\n                                arrayclone.push(cloneVariable({&#39;variable&#39;:element}));\r\n                        });\r\n\r\n                        return arrayclone;\r\n                }\r\n\r\n                var objectclone = {};\r\n\r\n                Object.keys(variable).forEach((field) =&gt; {\r\n                        objectclone[field] = cloneVariable({&#39;variable&#39;:variable[field]});\r\n                });\r\n\r\n                return objectclone;\r\n        }\r\n\r\n        return variable;\r\n    }\r\n"},{"score":22,"body_markdown":"In ECMAScript 2018\r\n\r\n    let objClone = { ...obj };\r\n\r\nBe aware that **nested objects** are still copied **as a reference.**"},{"score":3,"body_markdown":"**According to the [Airbnb JavaScript Style Guide][1]** with 404 contributors:\r\n\r\n&gt; Prefer the object spread operator over Object.assign to shallow-copy\r\n&gt; objects. Use the object rest operator to get a new object with certain\r\n&gt; properties omitted.\r\n\r\n    // very bad\r\n    const original = { a: 1, b: 2 };\r\n    const copy = Object.assign(original, { c: 3 }); // this mutates `original` ‡≤†_‡≤†\r\n    delete copy.a; // so does this\r\n    \r\n    // bad\r\n    const original = { a: 1, b: 2 };\r\n    const copy = Object.assign({}, original, { c: 3 }); // copy =&gt; { a: 1, b: 2, c: 3 }\r\n    \r\n    // good\r\n    const original = { a: 1, b: 2 };\r\n    const copy = { ...original, c: 3 }; // copy =&gt; { a: 1, b: 2, c: 3 }\r\n    \r\n    const { a, ...noA } = copy; // noA =&gt; { b: 2, c: 3 }\r\n\r\n\r\n**Also I&#39;d like to warn you that even though Airbnb hardly recommends the object spread operator approach. Keep in mind that Microsoft Edge still does not support this 2018 feature yet.**\r\n\r\n[ES2016+ Compat table &gt;&gt;][2]\r\n\r\n\r\n  [1]: https://github.com/airbnb/javascript#objects--rest-spread\r\n  [2]: http://kangax.github.io/compat-table/es2016plus/"},{"score":7,"body_markdown":"(The following was mainly an integration of @[Maciej Bukowski]( https://stackoverflow.com/a/39029912 ), @[A. Levy]( https://stackoverflow.com/a/728694 ), @[Jan Turo≈à]( https://stackoverflow.com/a/9023088 ), @[Redu]( https://stackoverflow.com/a/37503916 )&#39;s answers, and @[LeviRoberts]( https://stackoverflow.com/questions/728360/how-do-i-correctly-clone-a-javascript-object/53737490#comment96229185_53737490 ), @[RobG]( https://stackoverflow.com/q/728360#comment42972840_9023088 )&#39;s comments, many thanks to them!!!)\r\n\r\n\r\n**Deep copy**? ‚Äî YES! (mostly);  \r\n**Shallow copy**? ‚Äî NO! (except `Proxy`).\r\n\r\nI sincerely welcome everyone to test `clone()`.  \r\nIn addition, `defineProp()` is designed to easily and quickly *(re)define or copy* any type of descriptor.\r\n\r\n\r\n# Function\r\n\r\n```JavaScript\r\n&quot;use strict&quot;\r\nfunction clone(object) {\r\n  /*\r\n    Deep copy objects by value rather than by reference,\r\n    exception: `Proxy`\r\n  */\r\n\r\n  const seen = new WeakMap()\r\n\r\n  return clone(object)\r\n\r\n\r\n  function clone(object) {\r\n    if (object !== Object(object)) return object /*\r\n    ‚Äî‚Äî Check if the object belongs to a primitive data type */\r\n\r\n    if (object instanceof Node) return object.cloneNode(true) /*\r\n    ‚Äî‚Äî Clone DOM trees */\r\n\r\n    let _object // The clone of object\r\n\r\n    switch (object.constructor) {\r\n      case Array:\r\n      case Object:\r\n        _object = cloneObject(object)\r\n        break\r\n\r\n      case Date:\r\n        _object = new Date(+object)\r\n        break\r\n\r\n      case Function:\r\n        const fnStr = String(object)\r\n\r\n        _object = new Function(&quot;return &quot; +\r\n          (/^(?!function |[^{]+?=&gt;)[^(]+?\\(/.test(fnStr)\r\n            ? &quot;function &quot; : &quot;&quot;\r\n          ) + fnStr\r\n        )()\r\n\r\n        copyPropDescs(_object, object)\r\n        break\r\n\r\n      case RegExp:\r\n        _object = new RegExp(object)\r\n        break\r\n\r\n      default:\r\n        switch (Object.prototype.toString.call(object.constructor)) {\r\n          //                              // Stem from:\r\n          case &quot;[object Function]&quot;:       // `class`\r\n          case &quot;[object Undefined]&quot;:      // `Object.create(null)`\r\n            _object = cloneObject(object)\r\n            break\r\n\r\n          default:                        // `Proxy`\r\n            _object = object\r\n        }\r\n    }\r\n\r\n    return _object\r\n  }\r\n\r\n\r\n  function cloneObject(object) {\r\n    if (seen.has(object)) return seen.get(object) /*\r\n    ‚Äî‚Äî Handle recursive references (circular structures) */\r\n\r\n    const _object = Array.isArray(object)\r\n      ? []\r\n      : Object.create(Object.getPrototypeOf(object)) /*\r\n        ‚Äî‚Äî Assign [[Prototype]] for inheritance */\r\n\r\n    seen.set(object, _object) /*\r\n    ‚Äî‚Äî Make `_object` the associative mirror of `object` */\r\n\r\n    Reflect.ownKeys(object).forEach(key =&gt;\r\n      defineProp(_object, key, { value: clone(object[key]) }, object)\r\n    )\r\n\r\n    return _object\r\n  }\r\n\r\n\r\n  function copyPropDescs(target, source) {\r\n    Object.defineProperties(target,\r\n      Object.getOwnPropertyDescriptors(source)\r\n    )\r\n  }\r\n}\r\n\r\n\r\nfunction defineProp(object, key, descriptor = {}, copyFrom = {}) {\r\n  const { configurable: _configurable, writable: _writable }\r\n    = Object.getOwnPropertyDescriptor(object, key)\r\n    || { configurable: true, writable: true }\r\n\r\n  const test = _configurable // Can redefine property\r\n    &amp;&amp; (_writable === undefined || _writable) // Can assign to property\r\n\r\n  if (!test || arguments.length &lt;= 2) return test\r\n\r\n  const basisDesc = Object.getOwnPropertyDescriptor(copyFrom, key)\r\n    || { configurable: true, writable: true } // Custom‚Ä¶\r\n    || {}; // ‚Ä¶or left to native default settings\r\n\r\n  [&quot;get&quot;, &quot;set&quot;, &quot;value&quot;, &quot;writable&quot;, &quot;enumerable&quot;, &quot;configurable&quot;]\r\n    .forEach(attr =&gt;\r\n      descriptor[attr] === undefined &amp;&amp;\r\n      (descriptor[attr] = basisDesc[attr])\r\n    )\r\n\r\n  const { get, set, value, writable, enumerable, configurable }\r\n    = descriptor\r\n\r\n  return Object.defineProperty(object, key, {\r\n    enumerable, configurable, ...get || set\r\n      ? { get, set } // Accessor descriptor\r\n      : { value, writable } // Data descriptor\r\n  })\r\n}\r\n```\r\n\r\n## // Tests\r\n\r\n```JavaScript\r\n&quot;use strict&quot;\r\nconst obj0 = {\r\n  u: undefined,\r\n  nul: null,\r\n  t: true,\r\n  num: 9,\r\n  str: &quot;&quot;,\r\n  sym: Symbol(&quot;symbol&quot;),\r\n  [Symbol(&quot;e&quot;)]: Math.E,\r\n  arr: [[0], [1, 2]],\r\n  d: new Date(),\r\n  re: /f/g,\r\n  get g() { return 0 },\r\n  o: {\r\n    n: 0,\r\n    o: { f: function (...args) { } }\r\n  },\r\n  f: {\r\n    getAccessorStr(object) {\r\n      return []\r\n        .concat(...\r\n          Object.values(Object.getOwnPropertyDescriptors(object))\r\n            .filter(desc =&gt; desc.writable === undefined)\r\n            .map(desc =&gt; Object.values(desc))\r\n        )\r\n        .filter(prop =&gt; typeof prop === &quot;function&quot;)\r\n        .map(String)\r\n    },\r\n    f0: function f0() { },\r\n    f1: function () { },\r\n    f2: a =&gt; a / (a + 1),\r\n    f3: () =&gt; 0,\r\n    f4(params) { return param =&gt; param + params },\r\n    f5: (a, b) =&gt; ({ c = 0 } = {}) =&gt; a + b + c\r\n  }\r\n}\r\n\r\ndefineProp(obj0, &quot;s&quot;, { set(v) { this._s = v } })\r\ndefineProp(obj0.arr, &quot;tint&quot;, { value: { is: &quot;non-enumerable&quot; } })\r\nobj0.arr[0].name = &quot;nested array&quot;\r\n\r\n\r\nlet obj1 = clone(obj0)\r\nobj1.o.n = 1\r\nobj1.o.o.g = function g(a = 0, b = 0) { return a + b }\r\nobj1.arr[1][1] = 3\r\nobj1.d.setTime(+obj0.d + 60 * 1000)\r\nobj1.arr.tint.is = &quot;enumerable? no&quot;\r\nobj1.arr[0].name = &quot;a nested arr&quot;\r\ndefineProp(obj1, &quot;s&quot;, { set(v) { this._s = v + 1 } })\r\ndefineProp(obj1.re, &quot;multiline&quot;, { value: true })\r\n\r\nconsole.log(&quot;\\n\\n&quot; + &quot;-&quot;.repeat(2 ** 6))\r\n\r\n\r\n\r\n\r\nconsole.log(&quot;&gt;:&gt;: Test - Routinely&quot;)\r\n\r\nconsole.log(&quot;obj0:\\n &quot;, JSON.stringify(obj0))\r\nconsole.log(&quot;obj1:\\n &quot;, JSON.stringify(obj1))\r\nconsole.log()\r\n\r\nconsole.log(&quot;obj0:\\n &quot;, obj0)\r\nconsole.log(&quot;obj1:\\n &quot;, obj1)\r\nconsole.log()\r\n\r\nconsole.log(&quot;obj0\\n &quot;,\r\n  &quot;.arr.tint:&quot;, obj0.arr.tint, &quot;\\n &quot;,\r\n  &quot;.arr[0].name:&quot;, obj0.arr[0].name\r\n)\r\nconsole.log(&quot;obj1\\n &quot;,\r\n  &quot;.arr.tint:&quot;, obj1.arr.tint, &quot;\\n &quot;,\r\n  &quot;.arr[0].name:&quot;, obj1.arr[0].name\r\n)\r\nconsole.log()\r\n\r\nconsole.log(&quot;Accessor-type descriptor\\n &quot;,\r\n  &quot;of obj0:&quot;, obj0.f.getAccessorStr(obj0), &quot;\\n &quot;,\r\n  &quot;of obj1:&quot;, obj1.f.getAccessorStr(obj1), &quot;\\n &quot;,\r\n  &quot;set (obj0 &amp; obj1) .s :&quot;, obj0.s = obj1.s = 0, &quot;\\n &quot;,\r\n  &quot;  ‚Üí (obj0 , obj1) ._s:&quot;, obj0._s, &quot;,&quot;, obj1._s\r\n)\r\n\r\nconsole.log(&quot;‚Äî‚Äî obj0 has not been interfered.&quot;)\r\n\r\nconsole.log(&quot;\\n\\n&quot; + &quot;-&quot;.repeat(2 ** 6))\r\n\r\n\r\n\r\n\r\nconsole.log(&quot;&gt;:&gt;: Test - Circular structures&quot;)\r\n\r\nobj0.o.r = {}\r\nobj0.o.r.recursion = obj0.o\r\nobj0.arr[1] = obj0.arr\r\n\r\nobj1 = clone(obj0)\r\nconsole.log(&quot;obj0:\\n &quot;, obj0)\r\nconsole.log(&quot;obj1:\\n &quot;, obj1)\r\n\r\nconsole.log(&quot;Clear obj0&#39;s recursion:&quot;,\r\n  obj0.o.r.recursion = null, obj0.arr[1] = 1\r\n)\r\nconsole.log(\r\n  &quot;obj0\\n &quot;,\r\n  &quot;.o.r:&quot;, obj0.o.r, &quot;\\n &quot;,\r\n  &quot;.arr:&quot;, obj0.arr\r\n)\r\nconsole.log(\r\n  &quot;obj1\\n &quot;,\r\n  &quot;.o.r:&quot;, obj1.o.r, &quot;\\n &quot;,\r\n  &quot;.arr:&quot;, obj1.arr\r\n)\r\nconsole.log(&quot;‚Äî‚Äî obj1 has not been interfered.&quot;)\r\n\r\n\r\nconsole.log(&quot;\\n\\n&quot; + &quot;-&quot;.repeat(2 ** 6))\r\n\r\n\r\n\r\n\r\nconsole.log(&quot;&gt;:&gt;: Test - Classes&quot;)\r\n\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name\r\n  }\r\n}\r\n\r\nclass Boy extends Person { }\r\nBoy.prototype.sex = &quot;M&quot;\r\n\r\nconst boy0 = new Boy\r\nboy0.hobby = { sport: &quot;spaceflight&quot; }\r\n\r\nconst boy1 = clone(boy0)\r\nboy1.hobby.sport = &quot;superluminal flight&quot;\r\n\r\nboy0.name = &quot;one&quot;\r\nboy1.name = &quot;neo&quot;\r\n\r\nconsole.log(&quot;boy0:\\n &quot;, boy0)\r\nconsole.log(&quot;boy1:\\n &quot;, boy1)\r\nconsole.log(&quot;boy1&#39;s prototype === boy0&#39;s:&quot;,\r\n  Object.getPrototypeOf(boy1) === Object.getPrototypeOf(boy0)\r\n)\r\n```\r\n\r\n\r\n# References\r\n\r\n1. [`Object.create()` | MDN]( https://mdn.io/Object/create )\r\n2. [`Object.defineProperties()` | MDN]( https://mdn.io/Object/defineProperties )\r\n3. [Enumerability and ownership of properties | MDN]( https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties#Detection_Table )\r\n4. [TypeError: cyclic object value | MDN]( https://mdn.io/Errors/Cyclic_object_value )\r\n\r\n\r\n# Language tricks used\r\n\r\n1. [Conditionally add prop to object]( https://stackoverflow.com/a/40560953 )"},{"score":10,"body_markdown":"I think there is a simple and working answer. In deep copying there are two concerns:\r\n\r\n 1. Keep properties independent to each other.\r\n 2. And keep the methods alive on cloned object.\r\n\r\nSo I think one simple solution will be to first serialize and deserialize and then do an assign on it to copy functions too.\r\n\r\n    let deepCloned = JSON.parse(JSON.stringify(source));\r\n    let merged = Object.assign({}, source);\r\n    Object.assign(merged, deepCloned);\r\n\r\nAlthough this question has many answers, I hope this one helps too."},{"score":1,"body_markdown":"Using [defaults][1] (historically specific to nodejs but now usable from the browser thanks to modern JS):\r\n\r\n    import defaults from &#39;object.defaults&#39;;\r\n\r\n    const myCopy = defaults({}, myObject);\r\n\r\n  [1]: https://www.npmjs.com/package/defaults"},{"score":1,"body_markdown":"To support a better understanding of copying of objects, [this illustrative jsbin may be of value][1]\r\n\r\n    class base {\r\n      get under(){return true}\r\n    }\r\n\r\n    class a extends base {}\r\n\r\n    const b = {\r\n      get b1(){return true},\r\n      b: true\r\n    }\r\n\r\n    console.log(&#39;Object assign&#39;)\r\n    let t1 = Object.create(b)\r\n    t1.x = true\r\n    const c = Object.assign(t1, new a())\r\n    console.log(c.b1 ? &#39;prop value copied&#39;: &#39;prop value gone&#39;)\r\n    console.log(c.x ? &#39;assigned value copied&#39;: &#39;assigned value gone&#39;)\r\n    console.log(c.under ? &#39;inheritance ok&#39;: &#39;inheritance gone&#39;)\r\n    console.log(c.b1 ? &#39;get value unchanged&#39; : &#39;get value lost&#39;)\r\n    c.b1 = false\r\n    console.log(c.b1? &#39;get unchanged&#39; : &#39;get lost&#39;)\r\n    console.log(&#39;-----------------------------------&#39;)\r\n    console.log(&#39;Object assign  - order swopped&#39;)\r\n    t1 = Object.create(b)\r\n    t1.x = true\r\n    const d = Object.assign(new a(), t1)\r\n    console.log(d.b1 ? &#39;prop value copied&#39;: &#39;prop value gone&#39;)\r\n    console.log(d.x ? &#39;assigned value copied&#39;: &#39;assigned value gone&#39;)\r\n    console.log(d.under ? &#39;inheritance n/a&#39;: &#39;inheritance gone&#39;)\r\n    console.log(d.b1 ? &#39;get value copied&#39; : &#39;get value lost&#39;)\r\n    d.b1 = false\r\n    console.log(d.b1? &#39;get copied&#39; : &#39;get lost&#39;)\r\n    console.log(&#39;-----------------------------------&#39;)\r\n    console.log(&#39;Spread operator&#39;)\r\n    t1 = Object.create(b)\r\n    t2 = new a()\r\n    t1.x = true\r\n    const e = { ...t1, ...t2 }\r\n    console.log(e.b1 ? &#39;prop value copied&#39;: &#39;prop value gone&#39;)\r\n    console.log(e.x ? &#39;assigned value copied&#39;: &#39;assigned value gone&#39;)\r\n    console.log(e.under ? &#39;inheritance ok&#39;: &#39;inheritance gone&#39;)\r\n    console.log(e.b1 ? &#39;get value copied&#39; : &#39;get value lost&#39;)\r\n    e.b1 = false\r\n    console.log(e.b1? &#39;get copied&#39; : &#39;get lost&#39;)\r\n    console.log(&#39;-----------------------------------&#39;)\r\n    console.log(&#39;Spread operator on getPrototypeOf&#39;)\r\n    t1 = Object.create(b)\r\n    t2 = new a()\r\n    t1.x = true\r\n    const e1 = { ...Object.getPrototypeOf(t1), ...Object.getPrototypeOf(t2) }\r\n    console.log(e1.b1 ? &#39;prop value copied&#39;: &#39;prop value gone&#39;)\r\n    console.log(e1.x ? &#39;assigned value copied&#39;: &#39;assigned value gone&#39;)\r\n    console.log(e1.under ? &#39;inheritance ok&#39;: &#39;inheritance gone&#39;)\r\n    console.log(e1.b1 ? &#39;get value copied&#39; : &#39;get value lost&#39;)\r\n    e1.b1 = false\r\n    console.log(e1.b1? &#39;get copied&#39; : &#39;get lost&#39;)\r\n    console.log(&#39;-----------------------------------&#39;)\r\n    console.log(&#39;keys, defineProperty, getOwnPropertyDescriptor&#39;)\r\n    f = Object.create(b)\r\n    t2 = new a()\r\n    f.x = &#39;a&#39;\r\n    Object.keys(t2).forEach(key=&gt; {\r\n      Object.defineProperty(f,key,Object.getOwnPropertyDescriptor(t2, key))\r\n    })\r\n    console.log(f.b1 ? &#39;prop value copied&#39;: &#39;prop value gone&#39;)\r\n    console.log(f.x ? &#39;assigned value copied&#39;: &#39;assigned value gone&#39;)\r\n    console.log(f.under ? &#39;inheritance ok&#39;: &#39;inheritance gone&#39;)\r\n    console.log(f.b1 ? &#39;get value copied&#39; : &#39;get value lost&#39;)\r\n    f.b1 = false\r\n    console.log(f.b1? &#39;get copied&#39; : &#39;get lost&#39;)\r\n    console.log(&#39;-----------------------------------&#39;)\r\n    console.log(&#39;defineProperties, getOwnPropertyDescriptors&#39;)\r\n    let g = Object.create(b)\r\n    t2 = new a()\r\n    g.x = &#39;a&#39;\r\n    Object.defineProperties(g,Object.getOwnPropertyDescriptors(t2))\r\n    console.log(g.b1 ? &#39;prop value copied&#39;: &#39;prop value gone&#39;)\r\n    console.log(g.x ? &#39;assigned value copied&#39;: &#39;assigned value gone&#39;)\r\n    console.log(g.under ? &#39;inheritance ok&#39;: &#39;inheritance gone&#39;)\r\n    console.log(g.b1 ? &#39;get value copied&#39; : &#39;get value lost&#39;)\r\n    g.b1 = false\r\n    console.log(g.b1? &#39;get copied&#39; : &#39;get lost&#39;)\r\n    console.log(&#39;-----------------------------------&#39;)\r\n\r\n\r\n\r\n\r\n\r\n  [1]: https://jsbin.com/sekarup/edit?js,console"},{"score":11,"body_markdown":"For a deep copy and clone, JSON.stringify then JSON.parse the object:\r\n```\r\nobj = { a: 0 , b: { c: 0}};\r\nlet deepClone = JSON.parse(JSON.stringify(obj));\r\nobj.a = 5;\r\nobj.b.c = 5;\r\nconsole.log(JSON.stringify(deepClone)); // { a: 0, b: { c: 0}}\r\n```"},{"score":1,"body_markdown":"Just as [this link][1] says use this code: &lt;br&gt;\r\n```js\r\nlet clone = Object.create(Object.getPrototypeOf(obj),\r\n Object.getOwnPropertyDescriptors(obj));\r\n```\r\n\r\n\r\n  [1]: https://javascript.info/prototype-methods"},{"score":3,"body_markdown":"Simple\r\n```javascript\r\nvar restore = { name:&#39;charlesi&#39;,\r\nage:9}\r\nvar prev_data ={\r\nname: &#39;charles&#39;\r\nage : 10\r\n}\r\n\r\nvar temp = JSON.stringify(prev_data)\r\nrestore = JSON.parse(temp)\r\n\r\nrestore = {\r\nname:&#39;charlie&#39;,\r\nage : 12}\r\n```\r\n\r\noutput prev_data:\r\n```javascript\r\n{\r\nname: &#39;charles&#39;\r\nage : 10\r\n} \r\n```"},{"score":7,"body_markdown":"&gt; ***[Use lodash _.cloneDeep().][1]***\r\n\r\n***Shallow Copy: lodash _.clone()***\r\n\r\n *A shallow copy can be made by simply copying the reference.*\r\n\r\n    let obj1 = {\r\n        a: 0,\r\n        b: {\r\n            c: 0,\r\n            e: {\r\n                f: 0\r\n            }\r\n        }\r\n    };\r\n    let obj3 = _.clone(obj1);\r\n    obj1.a = 4;\r\n    obj1.b.c = 4;\r\n    obj1.b.e.f = 100;\r\n\r\n    console.log(JSON.stringify(obj1));\r\n    //{&quot;a&quot;:4,&quot;b&quot;:{&quot;c&quot;:4,&quot;e&quot;:{&quot;f&quot;:100}}}\r\n\r\n    console.log(JSON.stringify(obj3));\r\n    //{&quot;a&quot;:0,&quot;b&quot;:{&quot;c&quot;:4,&quot;e&quot;:{&quot;f&quot;:100}}}\r\n\r\n[![Shallow Copy: lodash _.clone()][2]][2]\r\n\r\n\r\n***Deep Copy: lodash _.cloneDeep()***\r\n\r\n*fields are dereferenced: rather than references to objects being copied*\r\n\r\n    let obj1 = {\r\n        a: 0,\r\n        b: {\r\n            c: 0,\r\n            e: {\r\n                f: 0\r\n            }\r\n        }\r\n    };\r\n    let obj3 = _.cloneDeep(obj1);\r\n    obj1.a = 100;\r\n    obj1.b.c = 100;\r\n    obj1.b.e.f = 100;\r\n\r\n    console.log(JSON.stringify(obj1));\r\n    {&quot;a&quot;:100,&quot;b&quot;:{&quot;c&quot;:100,&quot;e&quot;:{&quot;f&quot;:100}}}\r\n\r\n    console.log(JSON.stringify(obj3));\r\n    {&quot;a&quot;:0,&quot;b&quot;:{&quot;c&quot;:0,&quot;e&quot;:{&quot;f&quot;:0}}}\r\n\r\n[![Deep Copy: lodash _.cloneDeep()][3]][3]\r\n\r\n\r\n  [1]: https://lodash.com/docs/4.17.15#cloneDeep\r\n  [2]: https://i.stack.imgur.com/vmysI.png\r\n  [3]: https://i.stack.imgur.com/z0M6n.png"},{"score":3,"body_markdown":"Object copy using ( **...** )\r\n\r\n    //bad\r\n    const original = { a: 1, b: 2 };\r\n    const copy = Object.assign({}, original, { c: 3 }); // copy =&gt; { a: 1, b: 2,c: 3 }\r\n\r\n    //good\r\n    const originalObj = { id: 5, name: &#39;San Francisco&#39;};\r\n    const copyObject = {...originalObj, pincode: 4444};\r\n    console.log(copyObject)  //{ id: 5, name: &#39;San Francisco&#39;, pincode: 4444 }\r\n\r\n\r\nSame can be use for **copying array** from one to other \r\n\r\n    const itemsCopy = [...items];"},{"score":0,"body_markdown":"    var x = {&#39;e&#39;: 2, &#39;d&#39;: 8, &#39;b&#39;: 5};\r\n    \r\n    const y = {};\r\n    for(let key in x) {\r\n    \ty[key] = x[key];\r\n    }\r\n    console.log(y); // =&gt;&gt;&gt; {e: 2, d: 8, b: 5}\r\n    \r\n    const z = {};\r\n    Object.keys(x).forEach(key =&gt; {\r\n    \tz[key] = x[key];\r\n    });\r\n    console.log(z); // =&gt;&gt;&gt; {e: 2, d: 8, b: 5}\r\n    \r\n    const w = {};\r\n    for(let i = 0; i &lt; Object.keys(x).length; i++) {\r\n    \tw[Object.keys(x)[i]] = x[Object.keys(x)[i]];\r\n    }\r\n    console.log(w); // =&gt;&gt;&gt; {e: 2, d: 8, b: 5}\r\n    \r\n    const v = {};\r\n    for(let key of Object.keys(x)) {\r\n        v[key] = x[key];\r\n    }\r\n    console.log(v); // =&gt;&gt;&gt; {e: 2, d: 8, b: 5}\r\n    \r\n    x[&#39;q&#39;] = 100;   // Altering x will not affect the other objects\r\n    \r\n    console.log(x); // =&gt;&gt;&gt; {e: 2, d: 8, b: 5, q: 100}\r\n    console.log(y); // =&gt;&gt;&gt; {e: 2, d: 8, b: 5}\r\n    console.log(z); // =&gt;&gt;&gt; {e: 2, d: 8, b: 5}\r\n    console.log(w); // =&gt;&gt;&gt; {e: 2, d: 8, b: 5}\r\n    console.log(v); // =&gt;&gt;&gt; {e: 2, d: 8, b: 5}"},{"score":4,"body_markdown":"Simple recursive method to clone an object. Also could use lodash.clone.\r\n\r\n&lt;!-- begin snippet: js hide: false console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let clone = (obj) =&gt; {\r\n    \tlet obj2 = Array.isArray(obj) ? [] : {};\r\n    \tfor(let k in obj) {\r\n              obj2[k] = (typeof obj[k] === &#39;object&#39; ) ? clone(obj[k]) :  obj[k];\r\n            }\r\n            return obj2;\r\n        }\r\n\r\n    let w = { name: &quot;Apple&quot;, types: [&quot;Fuji&quot;, &quot;Gala&quot;]};\r\n    let x = clone(w);\r\n    w.name = &quot;Orange&quot;;\r\n    w.types = [&quot;Navel&quot;];\r\n    console.log(x);\r\n    console.log(w);\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\n"},{"score":2,"body_markdown":"The solution ```JSON.parse(JSON.stringify(orig_obj)``` as stated by many peers here for deep_cloning has several issues which I found, and they are listed below:\r\n\r\n1. It discards the entries while copying whose values are ```undefined``` in the original object,\r\n2. If there are some values like ```Infinity```, ```NaN``` etc, they will be converted into ```null``` while copying,\r\n3. If there is a ```Date``` type in the original object, it will be stringified in the cloned object (```typeof date_entry --&gt; string```).  \r\n\r\nFound an effective way for cloning an object, and it worked well for me in all sort of scenarios. Please have a look at below code, as it has resolved all above mentioned pitfalls of ```JSON.parse(...)```, yet resulting in proper deep-cloning:\r\n\r\n```\r\nvar orig_obj = {\r\n  string: &#39;my_str&#39;,\r\n  number: 123,\r\n  bool: false,\r\n  nul: null,\r\n  nested : {\r\n  \tvalue : true\r\n  },\r\n  nan : NaN,\r\n  date: new Date(), \r\n  undef: undefined,\r\n  inf: Infinity,\r\n}\r\nconsole.log(&quot;original_obj before modification: &quot;, orig_obj, &quot;\\n&quot;);\r\nconsole.log(typeof orig_obj.date, &quot;\\n&quot;);\r\n\r\nvar clone_obj = Object.assign({}, orig_obj);\r\n\r\n//this below loop will help in deep cloning and solving above issues\r\nfor(let prop in orig_obj) {\r\n\tif(typeof orig_obj[prop] === &quot;object&quot;) {\r\n\t\tif(orig_obj[prop] instanceof Date)\r\n\t\t\tclone_obj[prop] = orig_obj[prop];\r\n\t\telse {\r\n\t\t\tclone_obj[prop] = JSON.parse(JSON.stringify(orig_obj[prop]));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nconsole.log(&quot;cloned_obj before modification: &quot;, orig_obj, &quot;\\n&quot;);\r\n\r\nclone_obj.bool = true;\r\nclone_obj.nested.value = &quot;false&quot;;\r\n\r\nconsole.log(&quot;original_obj post modification: &quot;, orig_obj, &quot;\\n&quot;);\r\nconsole.log(&quot;cloned_obj post modification: &quot;, clone_obj, &quot;\\n&quot;);\r\nconsole.log(typeof clone_obj.date);\r\n```"},{"score":10,"body_markdown":"#Performance\r\n\r\nToday 2020.04.30 I perform tests of chosen solutions on Chrome v81.0, Safari v13.1 and Firefox v75.0 on MacOs High Sierra v10.13.6. \r\n\r\nI focus on speed of copy DATA (object with simple type fields, not methods etc.). The solutions A-I can make only shallow copy, solutions J-U can make deep copy.\r\n\r\n###Results for shallow copy\r\n\r\n* solution `{...obj}` (A) is fastest on chrome and firefox and medium fast on safari\r\n* solution based on `Object.assign` (B) is fast on all browsers\r\n* jQuery (E) and lodash (F,G,H) solutions are medium/quite fast\r\n* solution `JSON.parse/stringify` (K) is quite slow\r\n* solutions D and U are slow on all browsers\r\n\r\n\r\n[![enter image description here][1]][1]\r\n\r\n###Results for deep copy\r\n\r\n* solution Q is fastest on all browsers\r\n* jQuery (L) and lodash (J) are medium fast\r\n* solution `JSON.parse/stringify` (K) is quite slow\r\n* solution U is slowest on all browsers\r\n* lodash (J) and solution U crash on Chrome for 1000 level deep object\r\n\r\n[![enter image description here][2]][2]\r\n\r\nDetails\r\n-\r\n\r\nFor choosen solutions: \r\n[A](https://stackoverflow.com/a/44950864/860099) \r\n[B](https://stackoverflow.com/a/30042948/860099)\r\nC(my)\r\n[D](https://stackoverflow.com/a/49497485/860099)\r\n[E](https://stackoverflow.com/a/5164215/860099)\r\n[F](https://stackoverflow.com/a/11024936/860099)\r\n[G](https://stackoverflow.com/a/13850856/860099)\r\n[H](https://stackoverflow.com/a/11024936/860099)\r\n[I](https://stackoverflow.com/a/728694/860099)\r\n[J](https://stackoverflow.com/a/57504513/860099)\r\n[K](https://stackoverflow.com/a/10869248/860099)\r\n[L](https://stackoverflow.com/a/5164215/860099)\r\n[M](https://stackoverflow.com/a/728400/860099)\r\n[N](https://stackoverflow.com/a/728395/860099)\r\n[O](https://stackoverflow.com/a/1042676/860099)\r\n[P](https://stackoverflow.com/a/33273256/860099)\r\n[Q](https://stackoverflow.com/a/24648941/860099)\r\n[R](https://stackoverflow.com/a/24648941/860099)\r\n[S](https://stackoverflow.com/a/39029912/860099)\r\n[T](https://stackoverflow.com/a/11462081/860099)\r\n[U](https://stackoverflow.com/a/53737490/860099),\r\n I perform 4 tests\r\n\r\n* shallow-small: object with 10 non-nested fields - you can run it [HERE](https://jsbench.me/0xk9l5ci9x/1)\r\n* shallow-big: object with 1000 non-nested fields - you can run it [HERE](https://jsbench.me/t0k9l64319/1)\r\n* deep-small: object with 10 levels-nested fields - you can run it [HERE](https://jsbench.me/pvk9l6pzfj/1)\r\n* deep-big: object with 1000 levels-nested fields - you can run it [HERE](https://jsbench.me/euk9l6x9jx/1)\r\n\r\nObjects used in tests are show in below snippet\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    let obj_ShallowSmall = {\r\n      field0: false,\r\n      field1: true,\r\n      field2: 1,\r\n      field3: 0,\r\n      field4: null,\r\n      field5: [],\r\n      field6: {},\r\n      field7: &quot;text7&quot;,\r\n      field8: &quot;text8&quot;,\r\n    }\r\n\r\n    let obj_DeepSmall = {\r\n      level0: {\r\n       level1: {\r\n        level2: {\r\n         level3: {\r\n          level4: {\r\n           level5: {\r\n            level6: {\r\n             level7: {\r\n              level8: {\r\n               level9: [[[[[[[[[[&#39;abc&#39;]]]]]]]]]],\r\n      }}}}}}}}},\r\n    };\r\n\r\n    let obj_ShallowBig = Array(1000).fill(0).reduce((a,c,i) =&gt; (a[&#39;field&#39;+i]=getField(i),a) ,{});\r\n\r\n\r\n    let obj_DeepBig = genDeepObject(1000);\r\n\r\n\r\n\r\n    // ------------------\r\n    // Show objects\r\n    // ------------------\r\n\r\n    console.log(&#39;obj_ShallowSmall:&#39;,JSON.stringify(obj_ShallowSmall));\r\n    console.log(&#39;obj_DeepSmall:&#39;,JSON.stringify(obj_DeepSmall));\r\n    console.log(&#39;obj_ShallowBig:&#39;,JSON.stringify(obj_ShallowBig));\r\n    console.log(&#39;obj_DeepBig:&#39;,JSON.stringify(obj_DeepBig));\r\n\r\n\r\n\r\n\r\n    // ------------------\r\n    // HELPERS\r\n    // ------------------\r\n\r\n    function getField(k) {\r\n      let i=k%10;\r\n      if(i==0) return false;\r\n      if(i==1) return true;\r\n      if(i==2) return k;\r\n      if(i==3) return 0;\r\n      if(i==4) return null;\r\n      if(i==5) return [];\r\n      if(i==6) return {};  \r\n      if(i&gt;=7) return &quot;text&quot;+k;\r\n    }\r\n\r\n    function genDeepObject(N) {\r\n      // generate: {level0:{level1:{...levelN: {end:[[[...N-times...[&#39;abc&#39;]...]]] }}}...}}}\r\n      let obj={};\r\n      let o=obj;\r\n      let arr = [];\r\n      let a=arr;\r\n\r\n      for(let i=0; i&lt;N; i++) {\r\n        o[&#39;level&#39;+i]={};\r\n        o=o[&#39;level&#39;+i];\r\n        let aa=[];\r\n        a.push(aa);\r\n        a=aa;\r\n      }\r\n\r\n      a[0]=&#39;abc&#39;;\r\n      o[&#39;end&#39;]=arr;\r\n      return obj;\r\n    }\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nBelow snippet presents tested solutions and shows differences between them\r\n\r\n&lt;!-- begin snippet: js hide: true console: true babel: false --&gt;\r\n\r\n&lt;!-- language: lang-js --&gt;\r\n\r\n    function A(obj) {\r\n      return {...obj}\r\n    }\r\n\r\n    function B(obj) {\r\n      return Object.assign({}, obj); \r\n    }\r\n\r\n    function C(obj) {\r\n      return Object.keys(obj).reduce( (a,c) =&gt; (a[c]=obj[c], a), {})\r\n    }\r\n\r\n    function D(obj) {\r\n      let copyOfObject = {};\r\n      Object.defineProperties(copyOfObject, Object.getOwnPropertyDescriptors(obj));\r\n      return copyOfObject;\r\n    }\r\n\r\n    function E(obj) {\r\n      return jQuery.extend({}, obj) // shallow\r\n    }\r\n\r\n    function F(obj) {\r\n      return _.clone(obj);\r\n    }\r\n\r\n    function G(obj) {\r\n      return _.clone(obj,true);\r\n    }\r\n\r\n    function H(obj) {\r\n      return _.extend({},obj);\r\n    }\r\n\r\n    function I(obj) {\r\n        if (null == obj || &quot;object&quot; != typeof obj) return obj;\r\n        var copy = obj.constructor();\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];\r\n        }\r\n        return copy;\r\n    }\r\n\r\n    function J(obj) {\r\n      return _.cloneDeep(obj,true);\r\n    }\r\n\r\n    function K(obj) {\r\n    \treturn JSON.parse(JSON.stringify(obj));\r\n    }\r\n\r\n    function L(obj) {\r\n      return jQuery.extend(true, {}, obj) // deep\r\n    }\r\n\r\n    function M(obj) {\r\n      if(obj == null || typeof(obj) != &#39;object&#39;)\r\n        return obj;    \r\n      var temp = new obj.constructor(); \r\n      for(var key in obj)\r\n        temp[key] = M(obj[key]);    \r\n      return temp;\r\n    }\r\n\r\n    function N(obj) {\r\n      let EClone = function(obj) {\r\n        var newObj = (obj instanceof Array) ? [] : {};\r\n        for (var i in obj) {\r\n          if (i == &#39;EClone&#39;) continue;\r\n          if (obj[i] &amp;&amp; typeof obj[i] == &quot;object&quot;) {\r\n            newObj[i] = EClone(obj[i]);\r\n          } else newObj[i] = obj[i]\r\n        } return newObj;\r\n      };\r\n\r\n    \treturn EClone(obj);\r\n    };\r\n\r\n    function O(obj) {\r\n        if (obj == null || typeof obj != &quot;object&quot;) return obj;\r\n        if (obj.constructor != Object &amp;&amp; obj.constructor != Array) return obj;\r\n        if (obj.constructor == Date || obj.constructor == RegExp || obj.constructor == Function ||\r\n            obj.constructor == String || obj.constructor == Number || obj.constructor == Boolean)\r\n            return new obj.constructor(obj);\r\n\r\n        let to = new obj.constructor();\r\n\r\n        for (var name in obj)\r\n        {\r\n            to[name] = typeof to[name] == &quot;undefined&quot; ? O(obj[name], null) : to[name];\r\n        }\r\n\r\n        return to;\r\n    }\r\n\r\n    function P(obj) {\r\n      function clone(target, source){\r\n\r\n          for(let key in source){\r\n\r\n              // Use getOwnPropertyDescriptor instead of source[key] to prevent from trigering setter/getter.\r\n              let descriptor = Object.getOwnPropertyDescriptor(source, key);\r\n              if(descriptor.value instanceof String){\r\n                  target[key] = new String(descriptor.value);\r\n              }\r\n              else if(descriptor.value instanceof Array){\r\n                  target[key] = clone([], descriptor.value);\r\n              }\r\n              else if(descriptor.value instanceof Object){\r\n                  let prototype = Reflect.getPrototypeOf(descriptor.value);\r\n                  let cloneObject = clone({}, descriptor.value);\r\n                  Reflect.setPrototypeOf(cloneObject, prototype);\r\n                  target[key] = cloneObject;\r\n              }\r\n              else {\r\n                  Object.defineProperty(target, key, descriptor);\r\n              }\r\n          }\r\n          let prototype = Reflect.getPrototypeOf(source);\r\n          Reflect.setPrototypeOf(target, prototype);\r\n          return target;\r\n      }\r\n      return clone({},obj);\r\n    }\r\n\r\n    function Q(obj) {\r\n        var copy;\r\n\r\n        // Handle the 3 simple types, and null or undefined\r\n        if (null == obj || &quot;object&quot; != typeof obj) return obj;\r\n\r\n        // Handle Date\r\n        if (obj instanceof Date) {\r\n            copy = new Date();\r\n            copy.setTime(obj.getTime());\r\n            return copy;\r\n        }\r\n\r\n        // Handle Array\r\n        if (obj instanceof Array) {\r\n            copy = [];\r\n            for (var i = 0, len = obj.length; i &lt; len; i++) {\r\n                copy[i] = Q(obj[i]);\r\n            }\r\n            return copy;\r\n        }\r\n\r\n        // Handle Object\r\n        if (obj instanceof Object) {\r\n            copy = {};\r\n            for (var attr in obj) {\r\n                if (obj.hasOwnProperty(attr)) copy[attr] = Q(obj[attr]);\r\n            }\r\n            return copy;\r\n        }\r\n\r\n        throw new Error(&quot;Unable to copy obj! Its type isn&#39;t supported.&quot;);\r\n    }\r\n\r\n    function R(obj) {\r\n        const gdcc = &quot;__getDeepCircularCopy__&quot;;\r\n        if (obj !== Object(obj)) {\r\n            return obj; // primitive value\r\n        }\r\n\r\n        var set = gdcc in obj,\r\n            cache = obj[gdcc],\r\n            result;\r\n        if (set &amp;&amp; typeof cache == &quot;function&quot;) {\r\n            return cache();\r\n        }\r\n        // else\r\n        obj[gdcc] = function() { return result; }; // overwrite\r\n        if (obj instanceof Array) {\r\n            result = [];\r\n            for (var i=0; i&lt;obj.length; i++) {\r\n                result[i] = R(obj[i]);\r\n            }\r\n        } else {\r\n            result = {};\r\n            for (var prop in obj)\r\n                if (prop != gdcc)\r\n                    result[prop] = R(obj[prop]);\r\n                else if (set)\r\n                    result[prop] = R(cache);\r\n        }\r\n        if (set) {\r\n            obj[gdcc] = cache; // reset\r\n        } else {\r\n            delete obj[gdcc]; // unset again\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function S(obj) {\r\n        const cache = new WeakMap(); // Map of old - new references\r\n\r\n        function copy(object) {\r\n            if (typeof object !== &#39;object&#39; ||\r\n                object === null ||\r\n                object instanceof HTMLElement\r\n            )\r\n                return object; // primitive value or HTMLElement\r\n\r\n            if (object instanceof Date) \r\n                return new Date().setTime(object.getTime());\r\n\r\n            if (object instanceof RegExp) \r\n                return new RegExp(object.source, object.flags);\r\n\r\n            if (cache.has(object)) \r\n                return cache.get(object);\r\n\r\n            const result = object instanceof Array ? [] : {};\r\n\r\n            cache.set(object, result); // store reference to object before the recursive starts\r\n\r\n            if (object instanceof Array) {\r\n                for(const o of object) {\r\n                     result.push(copy(o));\r\n                }\r\n                return result;\r\n            }\r\n\r\n            const keys = Object.keys(object); \r\n\r\n            for (const key of keys)\r\n                result[key] = copy(object[key]);\r\n\r\n            return result;\r\n        }\r\n\r\n        return copy(obj);\r\n    }\r\n\r\n    function T(obj){\r\n        var clonedObjectsArray = [];\r\n        var originalObjectsArray = []; //used to remove the unique ids when finished\r\n        var next_objid = 0;\r\n\r\n        function objectId(obj) {\r\n            if (obj == null) return null;\r\n            if (obj.__obj_id == undefined){\r\n                obj.__obj_id = next_objid++;\r\n                originalObjectsArray[obj.__obj_id] = obj;\r\n            }\r\n            return obj.__obj_id;\r\n        }\r\n\r\n        function cloneRecursive(obj) {\r\n            if (null == obj || typeof obj == &quot;string&quot; || typeof obj == &quot;number&quot; || typeof obj == &quot;boolean&quot;) return obj;\r\n\r\n            // Handle Date\r\n            if (obj instanceof Date) {\r\n                var copy = new Date();\r\n                copy.setTime(obj.getTime());\r\n                return copy;\r\n            }\r\n\r\n            // Handle Array\r\n            if (obj instanceof Array) {\r\n                var copy = [];\r\n                for (var i = 0; i &lt; obj.length; ++i) {\r\n                    copy[i] = cloneRecursive(obj[i]);\r\n                }\r\n                return copy;\r\n            }\r\n\r\n            // Handle Object\r\n            if (obj instanceof Object) {\r\n                if (clonedObjectsArray[objectId(obj)] != undefined)\r\n                    return clonedObjectsArray[objectId(obj)];\r\n\r\n                var copy;\r\n                if (obj instanceof Function)//Handle Function\r\n                    copy = function(){return obj.apply(this, arguments);};\r\n                else\r\n                    copy = {};\r\n\r\n                clonedObjectsArray[objectId(obj)] = copy;\r\n\r\n                for (var attr in obj)\r\n                    if (attr != &quot;__obj_id&quot; &amp;&amp; obj.hasOwnProperty(attr))\r\n                        copy[attr] = cloneRecursive(obj[attr]);                 \r\n\r\n                return copy;\r\n            }       \r\n\r\n\r\n            throw new Error(&quot;Unable to copy obj! Its type isn&#39;t supported.&quot;);\r\n        }\r\n        var cloneObj = cloneRecursive(obj);\r\n\r\n\r\n\r\n        //remove the unique ids\r\n        for (var i = 0; i &lt; originalObjectsArray.length; i++)\r\n        {\r\n            delete originalObjectsArray[i].__obj_id;\r\n        };\r\n\r\n        return cloneObj;\r\n    }\r\n\r\n    function U(obj) {\r\n      /*\r\n        Deep copy objects by value rather than by reference,\r\n        exception: `Proxy`\r\n      */\r\n\r\n      const seen = new WeakMap()\r\n\r\n      return clone(obj)\r\n\r\n      function defineProp(object, key, descriptor = {}, copyFrom = {}) {\r\n        const { configurable: _configurable, writable: _writable }\r\n          = Object.getOwnPropertyDescriptor(object, key)\r\n          || { configurable: true, writable: true }\r\n\r\n        const test = _configurable // Can redefine property\r\n          &amp;&amp; (_writable === undefined || _writable) // Can assign to property\r\n\r\n        if (!test || arguments.length &lt;= 2) return test\r\n\r\n        const basisDesc = Object.getOwnPropertyDescriptor(copyFrom, key)\r\n          || { configurable: true, writable: true } // Custom‚Ä¶\r\n          || {}; // ‚Ä¶or left to native default settings\r\n\r\n        [&quot;get&quot;, &quot;set&quot;, &quot;value&quot;, &quot;writable&quot;, &quot;enumerable&quot;, &quot;configurable&quot;]\r\n          .forEach(attr =&gt;\r\n            descriptor[attr] === undefined &amp;&amp;\r\n            (descriptor[attr] = basisDesc[attr])\r\n          )\r\n\r\n        const { get, set, value, writable, enumerable, configurable }\r\n          = descriptor\r\n\r\n        return Object.defineProperty(object, key, {\r\n          enumerable, configurable, ...get || set\r\n            ? { get, set } // Accessor descriptor\r\n            : { value, writable } // Data descriptor\r\n        })\r\n      }\r\n\r\n      function clone(object) {\r\n        if (object !== Object(object)) return object /*\r\n        ‚Äî‚Äî Check if the object belongs to a primitive data type */\r\n\r\n        if (object instanceof Node) return object.cloneNode(true) /*\r\n        ‚Äî‚Äî Clone DOM trees */\r\n\r\n        let _object // The clone of object\r\n\r\n        switch (object.constructor) {\r\n          case Array:\r\n          case Object:\r\n            _object = cloneObject(object)\r\n            break\r\n\r\n          case Date:\r\n            _object = new Date(+object)\r\n            break\r\n\r\n          case Function:\r\n            const fnStr = String(object)\r\n\r\n            _object = new Function(&quot;return &quot; +\r\n              (/^(?!function |[^{]+?=&gt;)[^(]+?\\(/.test(fnStr)\r\n                ? &quot;function &quot; : &quot;&quot;\r\n              ) + fnStr\r\n            )()\r\n\r\n            copyPropDescs(_object, object)\r\n            break\r\n\r\n          case RegExp:\r\n            _object = new RegExp(object)\r\n            break\r\n\r\n          default:\r\n            switch (Object.prototype.toString.call(object.constructor)) {\r\n              //                              // Stem from:\r\n              case &quot;[object Function]&quot;:       // `class`\r\n              case &quot;[object Undefined]&quot;:      // `Object.create(null)`\r\n                _object = cloneObject(object)\r\n                break\r\n\r\n              default:                        // `Proxy`\r\n                _object = object\r\n            }\r\n        }\r\n\r\n        return _object\r\n      }\r\n\r\n\r\n      function cloneObject(object) {\r\n        if (seen.has(object)) return seen.get(object) /*\r\n        ‚Äî‚Äî Handle recursive references (circular structures) */\r\n\r\n        const _object = Array.isArray(object)\r\n          ? []\r\n          : Object.create(Object.getPrototypeOf(object)) /*\r\n            ‚Äî‚Äî Assign [[Prototype]] for inheritance */\r\n\r\n        seen.set(object, _object) /*\r\n        ‚Äî‚Äî Make `_object` the associative mirror of `object` */\r\n\r\n        Reflect.ownKeys(object).forEach(key =&gt;\r\n          defineProp(_object, key, { value: clone(object[key]) }, object)\r\n        )\r\n\r\n        return _object\r\n      }\r\n\r\n\r\n      function copyPropDescs(target, source) {\r\n        Object.defineProperties(target,\r\n          Object.getOwnPropertyDescriptors(source)\r\n        )\r\n      }\r\n    }\r\n     \r\n    // ------------------------\r\n    // Test properties\r\n    // ------------------------\r\n\r\n\r\n    console.log(`  shallow deep  func  circ  undefined date  RegExp bigInt`)\r\n\r\n    log(A);\r\n    log(B);\r\n    log(C);\r\n    log(D);\r\n    log(E);\r\n    log(F);\r\n    log(G);\r\n    log(H);\r\n    log(I);\r\n    log(J);\r\n    log(K);\r\n    log(L);\r\n    log(M);\r\n    log(N);\r\n    log(O);\r\n    log(P);\r\n    log(Q);\r\n    log(R);\r\n    log(S);\r\n    log(T);\r\n    log(U);\r\n\r\n    console.log(`  shallow deep  func  circ  undefined date  RegExp bigInt\r\n    ----\r\n    LEGEND:\r\n    shallow - solution create shallow copy\r\n    deep - solution create deep copy\r\n    func - solution copy functions\r\n    circ - solution can copy object with circular references\r\n    undefined - solution copy fields with undefined value\r\n    date - solution can copy date\r\n    RegExp - solution can copy fields with regular expressions\r\n    bigInt - solution can copy BigInt\r\n    `)\r\n\r\n\r\n    // ------------------------\r\n    // Helper functions\r\n    // ------------------------\r\n\r\n\r\n    function deepCompare(obj1,obj2) {\r\n      return JSON.stringify(obj1)===JSON.stringify(obj2);\r\n    }\r\n\r\n    function getCase() { // pure data case\r\n      return { \r\n        undef: undefined,\r\n        bool: true, num: 1, str: &quot;txt1&quot;,    \r\n        e1: null, e2: [], e3: {}, e4: 0, e5: false,\r\n        arr: [ false, 2, &quot;txt3&quot;, null, [], {},\r\n          [ true,4,&quot;txt5&quot;,null, [], {},  [true,6,&quot;txt7&quot;,null,[],{} ], \r\n            {bool: true,num: 8, str: &quot;txt9&quot;, e1:null, e2:[] ,e3:{} ,e4: 0, e5: false}\r\n          ],\r\n            {bool: true,num: 10, str: &quot;txt11&quot;, e1:null, e2:[] ,e3:{} ,e4: 0, e5: false}\r\n        ], \r\n        obj: { \r\n            bool: true, num: 12, str: &quot;txt13&quot;,\r\n            e1: null, e2: [], e3: {}, e4: 0, e5: false,\r\n            arr: [true,14,&quot;txt15&quot;,null,[],{} ],\r\n            obj: { \r\n              bool: true, num: 16, str: &quot;txt17&quot;,\r\n              e1: null, e2: [], e3: {}, e4: 0, e5: false,\r\n              arr: [true,18,&quot;txt19&quot;,null,[],{} ],\r\n              obj: {bool: true,num: 20, str: &quot;txt21&quot;, e1:null, e2:[] ,e3:{} ,e4: 0, e5: false}\r\n          } \r\n        } \r\n      };\r\n    }\r\n\r\n    function check(org, copy, field, newValue) {\r\n      copy[field] = newValue;\r\n      return deepCompare(org,copy); \r\n    }\r\n\r\n    function testFunc(f) {\r\n    \tlet o = { a:1, fun: (i,j)=&gt; i+j };\r\n      let c = f(o);\r\n      \r\n      let val = false\r\n      try{\r\n        val = c.fun(3,4)==7;\r\n      } catch(e) { }\r\n      return val;\r\n    } \r\n\r\n    function testCirc(f) {\r\n    \tfunction Circ() {\r\n        this.me = this;\r\n      }\r\n\r\n      var o = {\r\n          x: &#39;a&#39;,\r\n          circ: new Circ(),\r\n          obj_circ: null,\r\n      };\r\n      \r\n      o.obj_circ = o;\r\n\r\n      let val = false;\r\n\r\n      try{\r\n        let c = f(o);  \r\n        val = (o.obj_circ == o) &amp;&amp; (o.circ == o.circ.me);\r\n      } catch(e) { }\r\n      return val;\r\n    } \r\n\r\n    function testRegExp(f) {\r\n      let o = {\r\n        re: /a[0-9]+/,\r\n      };\r\n      \r\n      let val = false;\r\n\r\n      try{\r\n        let c = f(o);  \r\n        val = (String(c.re) == String(/a[0-9]+/));\r\n      } catch(e) { }\r\n      return val;\r\n    }\r\n\r\n    function testDate(f) {\r\n      let o = {\r\n        date: new Date(),\r\n      };\r\n      \r\n      let val = false;\r\n\r\n      try{\r\n        let c = f(o);  \r\n        val = (+new Date(c.date) == +new Date(o.date));\r\n      } catch(e) { }\r\n      return val;\r\n    }\r\n\r\n    function testBigInt(f) {\r\n      let val = false;\r\n      \r\n      try{\r\n        let o = {\r\n          big: 123n,\r\n        };\r\n      \r\n        let c = f(o);  \r\n      \r\n        val = o.big == c.big;\r\n      } catch(e) { }\r\n      \r\n      return val;\r\n    }\r\n\r\n    function log(f) {\r\n      let o = getCase();  // orginal object\r\n      let oB = getCase(); // &quot;backup&quot; used for shallow valid test\r\n      \r\n      let c1 = f(o); // copy 1 for reference\r\n      let c2 = f(o); // copy 2 for test shallow values\r\n      let c3 = f(o); // copy 3 for test deep values\r\n\r\n      let is_proper_copy = deepCompare(c1,o);  // shoud be true\r\n      \r\n      // shallow changes\r\n      let testShallow = \r\n        [ [&#39;bool&#39;,false],[&#39;num&#39;,666],[&#39;str&#39;,&#39;xyz&#39;],[&#39;arr&#39;,[]],[&#39;obj&#39;,{}] ]\r\n        .reduce((acc,curr)=&gt; acc &amp;&amp; check(c1,c2,curr[0], curr[1]), true );\r\n      \r\n      // should be true (original object shoud not have changed shallow fields)\r\n      let is_valid = deepCompare(o,oB); \r\n\r\n      // deep test (intruduce some change)\r\n      if (c3.arr[6]) c3.arr[6][7].num = 777;\r\n      \r\n      let diff_shallow = !testShallow; // shoud be true (shallow field was copied)\r\n      let diff_deep = !deepCompare(c1,c3);    // shoud be true (deep field was copied)\r\n      let can_copy_functions = testFunc(f);\r\n      let can_copy_circular = testCirc(f);\r\n      let can_copy_regexp = testRegExp(f);\r\n      let can_copy_date = testDate(f);\r\n      let can_copy_bigInt = testBigInt(f);\r\n      \r\n      let has_undefined = &#39;undef&#39; in c1; // field with undefined value is copied?  \r\n      let is_ok = is_valid &amp;&amp; is_proper_copy;\r\n      let b=(bool) =&gt; (bool+&#39;&#39;).padEnd(5,&#39; &#39;); // bool value to formated string\r\n      \r\n      testFunc(f);\r\n      \r\n      if(is_ok) {\r\n        console.log(`${f.name} ${b(diff_shallow)}   ${b(diff_deep)} ${b(can_copy_functions)} ${b(can_copy_circular)} ${b(has_undefined)}     ${b(can_copy_date)} ${b(can_copy_regexp)}  ${b(can_copy_bigInt)}`)\r\n      } else {\r\n        console.log(`${f.name}: INVALID ${is_valid} ${is_proper_copy}`,{c1})\r\n      }\r\n      \r\n    }\r\n\r\n&lt;!-- language: lang-html --&gt;\r\n\r\n    &lt;script src=&quot;https://code.jquery.com/jquery-3.5.0.min.js&quot; integrity=&quot;sha256-xNzN2a4ltkB44Mc/Jz3pT4iU1cmeR0FkXs4pru/JxaQ=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;\r\n    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js&quot;&gt;&lt;/script&gt;\r\n\r\n    This snippet only presents tested solutions and show differences between them (but it no make performence tests)\r\n\r\n&lt;!-- end snippet --&gt;\r\n\r\nBelow there are example results for Chrome for shallow-big object\r\n\r\n[![enter image description here][3]][3]\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/mCte1.png\r\n  [2]: https://i.stack.imgur.com/KxBqv.png\r\n  [3]: https://i.stack.imgur.com/zluC1.png"},{"score":22,"body_markdown":"Update 06 July 2020\r\n-------------------\r\n\r\nThere are three (3) ways to clone objects in JavaScript. As objects in JavaScript are reference values, you can&#39;t simply just copy using the =.\r\n\r\nThe ways are:\r\n\r\n\r\n```\r\nconst food = { food: &#39;apple&#39;, drink: &#39;milk&#39; }\r\n\r\n\r\n// 1. Using the &quot;Spread&quot;\r\n// ------------------\r\n\r\n{ ...food }\r\n\r\n\r\n// 2. Using &quot;Object.assign&quot;\r\n// ------------------\r\n\r\nObject.assign({}, food)\r\n\r\n\r\n// 3. &quot;JSON&quot;\r\n// ------------------\r\n\r\nJSON.parse(JSON.stringify(food))\r\n\r\n// RESULT:\r\n// { food: &#39;apple&#39;, drink: &#39;milk&#39; }\r\n\r\n```\r\n\r\nHope that this can be used as a reference summary.\r\n\r\n"},{"score":0,"body_markdown":"The most correct to copy object is use `Object.create`:\r\n```js\r\nObject.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\r\n```\r\n\r\nSuch a notation will make identically the same object with right prototype and hidden properties. "}],"score":3206}